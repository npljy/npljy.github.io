<!DOCTYPE html><html lang="zh-CN" data-dark><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="format-detection" content="telephone=no"><meta name="description" content="前端搬砖大老，写写搬砖那些事儿"><meta name="msvalidate.01" content="0FE4D8B3381D3D87088996B886E1E2BD"><meta name="google-adsense-account" content="ca-pub-8385136408348258"><meta name="keywords" content="前端壹菜鸟, HTML,CSS,JavaScript,ES6+,Sass,Less,Stylus,PostCSS,BEM,TailwindCSS,Bootstrap,React,Vue.js,Angular,Svelte,TypeScript,Vite,Webpack,npm,Yarn,pnpm,Redux,Zustand,Pinia,ReactRouter,VueRouter,ESLint,Prettier,Git,Node.js,ReactNative,Flutter,Electron,Next.js,Nuxt.js,Micro-frontends,WebAssembly,PWA,Three.js,前端,技术博客,转载,FrontEnd"><title>这儿有20道大厂面试题等你查收 | 前端壹菜鸟</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="icon" mask="" sizes="any" href="/img/blog.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/img/blog.ico"><link rel="apple-touch-icon" href="/img/blog.png"><link rel="apple-touch-icon-precomposed" href="/img/blog.png"><script type="text/javascript" src="/js/jquery.min.js"></script><script type="text/javascript" src="/js/isPhone.js"></script><script type="text/javascript" src="/js/fixedPage.jm.js"></script><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8385136408348258"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  document.head.append(bp)
})();
</script><script async src="https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-ETCMPGS7S6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);};gtag('js',new Date());gtag('config','G-ETCMPGS7S6');
</script><script type="application/ld+json">{
  "@context": "https://schema.org",
  "keywords": "HTML,CSS,JavaScript,ES6+,Sass,Less,Stylus,PostCSS,BEM,TailwindCSS,Bootstrap,React,Vue.js,Angular,Svelte,TypeScript,Vite,Webpack,npm,Yarn,pnpm,Redux,Zustand,Pinia,ReactRouter,VueRouter,ESLint,Prettier,Git,Node.js,ReactNative,Flutter,Electron,Next.js,Nuxt.js,Micro-frontends,WebAssembly,PWA,Three.js,前端,技术博客",
  "description": "前端搬砖大老，写写搬砖那些事儿",
  "operatingSystem": "Any",
  "permissions": "browser",
  "author": {
    "@type": "Person",
    "name": "前端壹菜鸟"
  },
  "@graph": [{
    "@type": "WebSite",
    "name": "前端壹菜鸟",
    "url": "https://xuehuayu.cn",
  }, {
    "@type": "WebSite",
    "name": "前端壹菜鸟",
    "url": "https://cainiaoblog.cn",
  }, ]
}</script><meta name="generator" content="Hexo 8.1.0"></head><body><div class="body_container"><div id="webtraf_17015" style="width:100%;display:flex;justify-content: center;"><script src="https://webtrafic.ru/ads.php?uid=17015" async></script></div><div id="header"><div class="site-name"><a id="logo" href="/.">前端壹菜鸟</a><p class="description">关注前端知识，收集精彩博文，做技术的搬运工</p></div><div id="nav-menu"><a class="current" href="/." target="_self"><i class="fa fa-home"> 首页</i></a><a href="/archives/" target="_self"><i class="fa fa-archive"> 归档</i></a><a href="/guestbook/" target="_self"><i class="fa fa-comments"> 留言</i></a><a href="https://afdian.com/a/big_old/thank" target="_self"><i class="fa fa-group"> 感谢</i></a><a href="https://love.xuehuayu.cn/" target="_self"><i class="fa fa-heart"> LOVE</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title c-post">这儿有20道大厂面试题等你查收</h1><div class="post-meta"><span class="date">2019-10-03</span><span> | </span><span class="reproduce">转载 </span><span> | </span><span class="category"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端 </a><a href="/categories/FrontEnd/">FrontEnd </a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 10.4k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 42</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" href="/article/c3a5c18.html#waline-comment"><span class="waline-comment-count" data-path="/article/c3a5c18.html">0</span><span> 条评论</span></a><div class="post-content"><p><code>原文地址：https://github.com/YvetteLau/Blog/issues/35</code></p>
<p>今年来，各大公司都缩减了HC，甚至是采取了“裁员”措施，在这样的大环境之下，想要获得一份更好的工作，必然需要付出更多的努力。</p>
<p>本文挑选了20到大厂面试题，大家在阅读时，建议不要先看我的答案，而是自己先思考一番。尽管，本文所有的答案，都是我在翻阅各种资料，思考并验证之后，才给出的。但因水平有限，本人的答案未必是最优的，如果您有更好的答案，欢迎给我留言。</p>
<p>本文篇幅较长，希望小伙伴们能够坚持读完，如果想加入交流群，可以通过文末的公众号添加我为好友。</p>
<span id="more"></span>

<h3 id="1-new的实现原理是什么？"><a href="#1-new的实现原理是什么？" class="headerlink" title="1. new的实现原理是什么？"></a>1. new的实现原理是什么？</h3><p><code>new</code> 的实现原理:</p>
<ol>
<li><p>创建一个空对象，构造函数中的this指向这个空对象</p>
</li>
<li><p>这个新对象被执行 [[原型]] 连接</p>
</li>
<li><p>执行构造函数方法，属性和方法被添加到this引用的对象中</p>
</li>
<li><p>如果构造函数中没有返回其它对象，那么返回this，即创建的这个的新对象，否则，返回构造函数中返回的对象。</p>
<p> function_new() {<br> let target &#x3D; {}; &#x2F;&#x2F;创建的新对象&#x2F;&#x2F;第一个参数是构造函数let [constructor, …args] &#x3D; […arguments];<br> &#x2F;&#x2F;执行[[原型]]连接;target 是 constructor 的实例<br> target.<strong>proto</strong> &#x3D; constructor.prototype;<br> &#x2F;&#x2F;执行构造函数，将属性或方法添加到创建的空对象上<br> let result &#x3D; constructor.apply(target, args);<br> if (result &amp;&amp; (typeof (result) &#x3D;&#x3D; “object” || typeof (result) &#x3D;&#x3D; “function”)) {<br>     &#x2F;&#x2F;如果构造函数执行的结构返回的是一个对象，那么返回这个对象return result;<br> }<br> &#x2F;&#x2F;如果构造函数返回的不是一个对象，返回创建的新对象return target;<br> }</p>
</li>
</ol>
<h3 id="2-如何正确判断this的指向？"><a href="#2-如何正确判断this的指向？" class="headerlink" title="2. 如何正确判断this的指向？"></a>2. 如何正确判断this的指向？</h3><p>如果用一句话说明 this 的指向，那么即是: 谁调用它，this 就指向谁。</p>
<p>但是仅通过这句话，我们很多时候并不能准确判断 this 的指向。因此我们需要借助一些规则去帮助自己：</p>
<p>this 的指向可以按照以下顺序判断:</p>
<h4 id="全局环境中的-this"><a href="#全局环境中的-this" class="headerlink" title="全局环境中的 this"></a>全局环境中的 this</h4><p>浏览器环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象 <code>window</code>;</p>
<p>node 环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部），this 都是空对象 <code>{}</code>;</p>
<h4 id="是否是-new-绑定"><a href="#是否是-new-绑定" class="headerlink" title="是否是 new 绑定"></a>是否是 <code>new</code> 绑定</h4><p>如果是 <code>new</code> 绑定，并且构造函数中没有返回 function 或者是 object，那么 this 指向这个新对象。如下:</p>
<blockquote>
<p>构造函数返回值不是 function 或 object。<code>new Super()</code> 返回的是 this 对象。</p>
</blockquote>
<pre><code>functionSuper(age) {
    this.age= age;
}

let instance =newSuper(&#39;26&#39;);
console.log(instance.age); //26
</code></pre>
<blockquote>
<p>构造函数返回值是 function 或 object，<code>new Super()</code>是返回的是Super种返回的对象。</p>
</blockquote>
<pre><code>functionSuper(age) {
    this.age= age;
    let obj = {a:&#39;2&#39;};
    return obj;
}

let instance =newSuper(&#39;hello&#39;);
console.log(instance);//{ a: &#39;2&#39; }console.log(instance.age); //undefined
</code></pre>
<h4 id="函数是否通过-call-apply-调用，或者使用了-bind-绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。"><a href="#函数是否通过-call-apply-调用，或者使用了-bind-绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。" class="headerlink" title="函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。"></a>函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。</h4><pre><code>functioninfo(){
    console.log(this.age);
}
var person = {
    age:20,
    info
}
var age =28;
var info =person.info;
info.call(person);   //20info.apply(person);  //20info.bind(person)(); //20
</code></pre>
<p>这里同样需要注意一种<strong>特殊</strong>情况，如果 call,apply 或者 bind 传入的第一个参数值是 <code>undefined</code> 或者 <code>null</code>，严格模式下<br>this 的值为传入的值 null &#x2F;undefined。非严格模式下，实际应用的默认绑定规则，this<br>指向全局对象(node环境为global，浏览器环境为window)</p>
<pre><code>functioninfo(){
    //node环境中:非严格模式 global，严格模式为null//浏览器环境中:非严格模式 window，严格模式为nullconsole.log(this);
    console.log(this.age);
}
var person = {
    age:20,
    info
}
var age =28;
var info =person.info;
//严格模式抛出错误；//非严格模式，node下输出undefined（因为全局的age不会挂在 global 上）//非严格模式。浏览器环境下输出 28（因为全局的age会挂在 window 上）info.call(null);
</code></pre>
<h4 id="隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为-xxx-fn"><a href="#隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为-xxx-fn" class="headerlink" title="隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: xxx.fn()"></a>隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: <code>xxx.fn()</code></h4><pre><code>functioninfo(){
    console.log(this.age);
}
var person = {
    age:20,
    info
}
var age =28;
person.info(); //20;执行的是隐式绑定
</code></pre>
<h4 id="默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。"><a href="#默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。" class="headerlink" title="默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。"></a>默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。</h4><p>非严格模式： node环境，执行全局对象 global，浏览器环境，执行全局对象 window。</p>
<p>严格模式：执行 undefined</p>
<pre><code>functioninfo(){
    console.log(this.age);
}
var age =28;
//严格模式；抛错//非严格模式，node下输出 undefined（因为全局的age不会挂在 global 上）//非严格模式。浏览器环境下输出 28（因为全局的age会挂在 window 上）//严格模式抛出，因为 this 此时是 undefinedinfo();
</code></pre>
<h4 id="箭头函数的情况："><a href="#箭头函数的情况：" class="headerlink" title="箭头函数的情况："></a>箭头函数的情况：</h4><p>箭头函数没有自己的this，继承外层上下文绑定的this。</p>
<pre><code>let obj = {
    age:20,
    info:function() {
        return () =&gt; {
            console.log(this.age); //this继承的是外层上下文绑定的this
        }
    }
}

let person = {age:28};
let info =obj.info();
info(); //20let info2 =obj.info.call(person);
info2(); //28
</code></pre>
<h3 id="3-深拷贝和浅拷贝的区别是什么？实现一个深拷贝"><a href="#3-深拷贝和浅拷贝的区别是什么？实现一个深拷贝" class="headerlink" title="3. 深拷贝和浅拷贝的区别是什么？实现一个深拷贝"></a>3. 深拷贝和浅拷贝的区别是什么？实现一个深拷贝</h3><p>深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝。</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><blockquote>
<p>深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。</p>
</blockquote>
<p>深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</p>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><blockquote>
<p>浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。</p>
</blockquote>
<p>可以使用 <code>for in</code>、 <code>Object.assign</code>、 扩展运算符 <code>...</code><br>、<code>Array.prototype.slice()</code>、<code>Array.prototype.concat()</code> 等，例如:</p>
<pre><code>let obj = {
    name:&#39;Yvette&#39;,
    age:18,
    hobbies: [&#39;reading&#39;, &#39;photography&#39;]
}
let obj2 =Object.assign({}, obj);
let obj3 = {...obj};

obj.name=&#39;Jack&#39;;
obj.hobbies.push(&#39;coding&#39;);
console.log(obj);//{ name: &#39;Jack&#39;, age: 18,hobbies: [ &#39;reading&#39;, &#39;photography&#39;, &#39;coding&#39; ] }console.log(obj2);//{ name: &#39;Yvette&#39;, age: 18,hobbies: [ &#39;reading&#39;, &#39;photography&#39;, &#39;coding&#39; ] }console.log(obj3);//{ name: &#39;Yvette&#39;, age: 18,hobbies: [ &#39;reading&#39;, &#39;photography&#39;, &#39;coding&#39; ] }
</code></pre>
<p>可以看出浅拷贝只最第一层属性进行了拷贝，当第一层的属性值是基本数据类型时，新的对象和原对象互不影响，但是如果第一层的属性值是复杂数据类型，那么新对象和原对象的属性值其指向的是同一块内存地址。</p>
<h4 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h4><blockquote>
<p>1.深拷贝最简单的实现是: <code>JSON.parse(JSON.stringify(obj))</code></p>
</blockquote>
<p><code>JSON.parse(JSON.stringify(obj))</code> 是最简单的实现方式，但是有一些缺陷：</p>
<ol>
<li>对象的属性值是函数时，无法拷贝。</li>
<li>原型链上的属性无法拷贝</li>
<li>不能正确的处理 Date 类型的数据</li>
<li>不能处理 RegExp</li>
<li>会忽略 symbol</li>
<li>会忽略 undefined</li>
</ol>
<blockquote>
<p>2.实现一个 deepClone 函数</p>
</blockquote>
<ol>
<li><p>如果是基本数据类型，直接返回</p>
</li>
<li><p>如果是 <code>RegExp</code> 或者 <code>Date</code> 类型，返回对应类型</p>
</li>
<li><p>如果是复杂数据类型，递归。</p>
</li>
<li><p>考虑循环引用的问题</p>
<p> functiondeepClone(obj, hash&#x3D;newWeakMap()) { &#x2F;&#x2F;递归拷贝if (obj instanceofRegExp) returnnewRegExp(obj);<br> if (obj instanceofDate) returnnewDate(obj);<br> if (obj &#x3D;&#x3D;&#x3D;null||typeof obj !&#x3D;&#x3D;’object’) {<br>     &#x2F;&#x2F;如果不是复杂数据类型，直接返回return obj;<br> }<br> if (hash.has(obj)) {<br>     returnhash.get(obj);<br> }<br> &#x2F;**     * 如果obj是数组，那么 obj.constructor 是 [Function: Array]     * 如果obj是对象，那么 obj.constructor 是 [Function: Object]*&#x2F;let t &#x3D;newobj.constructor();<br> hash.set(obj, t);<br> for (let key in obj) {<br>     &#x2F;&#x2F;递归if (obj.hasOwnProperty(key)) {&#x2F;&#x2F;是否是自身的属性<br>         t[key] &#x3D;deepClone(obj[key], hash);<br>     }<br> }<br> return t;<br> }</p>
</li>
</ol>
<h3 id="4-call-apply-的实现原理是什么？"><a href="#4-call-apply-的实现原理是什么？" class="headerlink" title="4. call&#x2F;apply 的实现原理是什么？"></a>4. call&#x2F;apply 的实现原理是什么？</h3><p>call 和 apply 的功能相同，都是改变 <code>this</code> 的执行，并立即执行函数。区别在于传参方式不同。</p>
<ul>
<li><p><code>func.call(thisArg, arg1, arg2, ...)</code>：第一个参数是 <code>this</code> 指向的对象，其它参数依次传入。</p>
</li>
<li><p><code>func.apply(thisArg, [argsArray])</code>：第一个参数是 <code>this</code> 指向的对象，第二个参数是数组或类数组。</p>
</li>
</ul>
<p>一起思考一下，如何模拟实现 <code>call</code> ？</p>
<p>首先，我们知道，函数都可以调用 <code>call</code>，说明 <code>call</code> 是函数原型上的方法，所有的实例都可以调用。即:<br><code>Function.prototype.call</code>。</p>
<ul>
<li>在 <code>call</code> 方法中获取调用<code>call()</code>函数</li>
<li>如果第一个参数没有传入，那么默认指向 <code>window / global</code>(非严格模式)</li>
<li>传入 <code>call</code> 的第一个参数是 this 指向的对象，根据隐式绑定的规则，我们知道 <code>obj.foo()</code>, <code>foo()</code> 中的 <code>this</code> 指向</li>
</ul>
<p><code>obj</code>;因此我们可以这样调用函数 <code>thisArgs.func(...args)</code></p>
<ul>
<li><p>返回执行结果</p>
<p>  Function.prototype.call&#x3D;function() {<br>  let [thisArg, …args] &#x3D; […arguments];<br>  if (!thisArg) {<br>      &#x2F;&#x2F;context为null或者是undefined<br>      thisArg &#x3D;typeofwindow&#x3D;&#x3D;&#x3D;’undefined’?global:window;<br>  }<br>  &#x2F;&#x2F;this的指向的是当前函数 func (func.call)thisArg.func&#x3D;this;<br>  &#x2F;&#x2F;执行函数let result &#x3D;thisArg.func(…args);<br>  deletethisArg.func; &#x2F;&#x2F;thisArg上并没有 func 属性，因此需要移除return result;<br>  }</p>
</li>
</ul>
<p>bind 的实现思路和 <code>call</code> 一致，仅参数处理略有差别。如下：</p>
<pre><code>Function.prototype.apply=function(thisArg, rest) {
    let result; //函数返回结果if (!thisArg) {
        //context为null或者是undefined
        thisArg =typeofwindow===&#39;undefined&#39;?global:window;
    }
    //this的指向的是当前函数 func (func.call)thisArg.func=this;
    if(!rest) {
        //第二个参数为 null / undefined
        result =thisArg.func();
    }else {
        result =thisArg.func(...rest);
    }
    deletethisArg.func; //thisArg上并没有 func 属性，因此需要移除return result;
}
</code></pre>
<h3 id="5-柯里化函数实现"><a href="#5-柯里化函数实现" class="headerlink" title="5. 柯里化函数实现"></a>5. 柯里化函数实现</h3><p>在开始之前，我们首先需要搞清楚函数柯里化的概念。</p>
<p>函数柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
<pre><code>constcurry= (fn, ...args) =&gt;args.length&lt;fn.length//参数长度不足时，重新柯里化该函数，等待接受新参数? (...arguments) =&gt;curry(fn, ...args, ...arguments)
        //参数长度满足时，执行函数:fn(...args);

functionsumFn(a, b, c) {
    return a + b + c;
}
var sum =curry(sumFn);
console.log(sum(2)(3)(5));//10console.log(sum(2, 3, 5));//10console.log(sum(2)(3, 5));//10console.log(sum(2, 3)(5));//10
</code></pre>
<blockquote>
<p>函数柯里化的主要作用：</p>
</blockquote>
<ul>
<li>参数复用</li>
<li>提前返回 – 返回接受余下的参数且返回结果的新函数</li>
<li>延迟执行 – 返回新函数，等待执行</li>
</ul>
<h3 id="6-如何让-a-1-a-2-a-3-的值为true？"><a href="#6-如何让-a-1-a-2-a-3-的值为true？" class="headerlink" title="6. 如何让 (a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) 的值为true？"></a>6. 如何让 (a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) 的值为true？</h3><blockquote>
<ol>
<li>利用隐式类型转换</li>
</ol>
</blockquote>
<p><code>==</code> 操作符在左右数据类型不一致时，会先进行隐式转换。</p>
<p><code>a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</code> 的值意味着其不可能是基本数据类型。因为如果 a 是 null 或者是 undefined<br>bool类型，都不可能返回true。</p>
<p>因此可以推测 a 是复杂数据类型，JS 中复杂数据类型只有 <code>object</code>，回忆一下，Object 转换为原始类型会调用什么方法？</p>
<ul>
<li><p>如果部署了 <code>[Symbol.toPrimitive]</code> 接口，那么调用此接口，若返回的不是基本数据类型，抛出错误。</p>
</li>
<li><p>如果没有部署 <code>[Symbol.toPrimitive]</code> 接口，那么根据要转换的类型，先调用 <code>valueOf</code> &#x2F; <code>toString</code></p>
</li>
</ul>
<ol>
<li><p>非Date类型对象，<code>hint</code> 是 <code>default</code> 时，调用顺序为：<code>valueOf</code> &gt;&gt;&gt; <code>toString</code>，即<code>valueOf</code><br>返回的不是基本数据类型，才会继续调用 <code>valueOf</code>，如果<code>toString</code> 返回的还不是基本数据类型，那么抛出错误。</p>
</li>
<li><p>如果 <code>hint</code> 是 <code>string</code>(Date对象的hint默认是string) ，调用顺序为：<code>toString</code> &gt;&gt;&gt;<br><code>valueOf</code>，即<code>toString</code> 返回的不是基本数据类型，才会继续调用 <code>valueOf</code>，如果<code>valueOf</code><br>返回的还不是基本数据类型，那么抛出错误。</p>
</li>
<li><p>如果 <code>hint</code> 是 <code>number</code>，调用顺序为： <code>valueOf</code> &gt;&gt;&gt; <code>toString</code></p>
<p> &#x2F;&#x2F;部署 [Symbol.toPrimitive] &#x2F; valueOf&#x2F; toString 皆可&#x2F;&#x2F;一次返回1，2，3 即可。let a &#x3D; {<br> [Symbol.toPrimitive]: (function(hint) {<br>         let i &#x3D;1;<br>         &#x2F;&#x2F;闭包的特性之一：i 不会被回收returnfunction() {<br>             return i++;<br>         }<br> })()<br> }</p>
</li>
</ol>
<blockquote>
<ol>
<li>利用数据劫持(Proxy&#x2F;Object.definedProperty)</li>
</ol>
</blockquote>
<pre><code>let i =1;
let a =newProxy({}, {
    i:1,
    get:function () {
        return () =&gt;this.i++;
    }
});
</code></pre>
<blockquote>
<ol>
<li>数组的 <code>toString</code> 接口默认调用数组的 <code>join</code> 方法，重新 <code>join</code> 方法</li>
</ol>
</blockquote>
<pre><code>let a = [1, 2, 3];
a.join=a.shift;
</code></pre>
<h3 id="7-什么是BFC？BFC的布局规则是什么？如何创建BFC？"><a href="#7-什么是BFC？BFC的布局规则是什么？如何创建BFC？" class="headerlink" title="7. 什么是BFC？BFC的布局规则是什么？如何创建BFC？"></a>7. 什么是BFC？BFC的布局规则是什么？如何创建BFC？</h3><p>Box 是 CSS 布局的对象和基本单位，页面是由若干个Box组成的。</p>
<p>元素的类型 和 <code>display</code> 属性，决定了这个 Box 的类型。不同类型的 Box 会参与不同的 Formatting Context。</p>
<blockquote>
<p>Formatting Context</p>
</blockquote>
<p>Formatting Context 是页面的一块渲染区域，并且有一套渲染规则，决定了其子元素将如何定位，以及和其它元素的关系和相互作用。</p>
<p>Formatting Context 有 BFC (Block formatting context)，IFC (Inline formatting<br>context)，FFC (Flex formatting context) 和 GFC (Grid formatting context)。FFC 和 GFC<br>为 CC3 中新增。</p>
<blockquote>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#block-formatting">BFC布局规则</a></p>
<ul>
<li>BFC内，盒子依次垂直排列。</li>
<li>BFC内，两个盒子的垂直距离由 <code>margin</code></li>
</ul>
<p>属性决定。属于同一个BFC的两个相邻Box的margin会发生重叠【符合合并原则的margin合并后是使用大的margin】</p>
<ul>
<li>BFC内，每个盒子的左外边缘接触内部盒子的左边缘（对于从右到左的格式，右边缘接触）。即使在存在浮动的情况下也是如此。除非创建新的BFC。</li>
<li>BFC的区域不会与float box重叠。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li>计算BFC的高度时，浮动元素也参与计算。</li>
</ul>
<blockquote>
<p>如何创建BFC</p>
</blockquote>
<ul>
<li>根元素</li>
<li>浮动元素（float 属性不为 none）</li>
<li>position 为 absolute 或 fixed</li>
<li>overflow 不为 visible 的块元素</li>
<li>display 为 inline-block, table-cell, table-caption</li>
</ul>
<blockquote>
<p>BFC 的应用</p>
</blockquote>
<ol>
<li>防止 margin 重叠 (同一个BFC内的两个两个相邻Box的 <code>margin</code> 会发生重叠，触发生成两个BFC，即不会重叠)</li>
<li>清除内部浮动 (创建一个新的 BFC，因为根据 BFC 的规则，计算 BFC 的高度时，浮动元素也参与计算)</li>
<li>自适应多栏布局 (BFC的区域不会与float box重叠。因此，可以触发生成一个新的BFC)</li>
</ol>
<h3 id="8-异步加载JS脚本的方式有哪些？"><a href="#8-异步加载JS脚本的方式有哪些？" class="headerlink" title="8. 异步加载JS脚本的方式有哪些？"></a>8. 异步加载JS脚本的方式有哪些？</h3><blockquote>
<p><code>&lt;script&gt;</code> 标签中增加 <code>async</code>(html5) 或者 <code>defer</code>(html4) 属性,脚本就会异步加载。</p>
</blockquote>
<pre><code>&lt;script src=&quot;../XXX.js&quot; defer&gt;&lt;/script&gt;
</code></pre>
<p><code>defer</code> 和 <code>async</code> 的区别在于：</p>
<ul>
<li><code>defer</code> 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），在window.onload 之前执行；</li>
<li><code>async</code> 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。</li>
<li>如果有多个 <code>defer</code> 脚本，会按照它们在页面出现的顺序加载</li>
<li>多个 <code>async</code> 脚本不能保证加载顺序</li>
</ul>
<blockquote>
<p>动态创建 <code>script</code> 标签</p>
</blockquote>
<p>动态创建的 <code>script</code> ，设置 <code>src</code> 并不会开始下载，而是要添加到文档中，JS文件才会开始下载。</p>
<pre><code>let script =document.createElement(&#39;script&#39;);
script.src=&#39;XXX.js&#39;;
// 添加到html文件中才会开始下载document.body.append(script);
</code></pre>
<blockquote>
<p>XHR 异步加载JS</p>
</blockquote>
<pre><code>let xhr =newXMLHttpRequest();
xhr.open(&quot;get&quot;, &quot;js/xxx.js&quot;,true);
xhr.send();
xhr.onreadystatechange=function() {
    if (xhr.readyState==4&amp;&amp;xhr.status==200) {
        eval(xhr.responseText);
    }
}
</code></pre>
<h3 id="9-ES5有几种方式可以实现继承？分别有哪些优缺点？"><a href="#9-ES5有几种方式可以实现继承？分别有哪些优缺点？" class="headerlink" title="9. ES5有几种方式可以实现继承？分别有哪些优缺点？"></a>9. ES5有几种方式可以实现继承？分别有哪些优缺点？</h3><p>ES5 有 6 种方式可以实现继承，分别为：</p>
<h4 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h4><p>原型链继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<pre><code>functionSuperType() {
    this.name=&#39;Yvette&#39;;
    this.colors= [&#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;];
}
SuperType.prototype.getName=function () {
    returnthis.name;
}
functionSubType() {
    this.age=22;
}
SubType.prototype=newSuperType();
SubType.prototype.getAge=function() {
    returnthis.age;
}
SubType.prototype.constructor= SubType;
let instance1 =newSubType();
instance1.colors.push(&#39;yellow&#39;);
console.log(instance1.getName()); //&#39;Yvette&#39;console.log(instance1.colors);//[ &#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;, &#39;yellow&#39; ]let instance2 =newSubType();
console.log(instance2.colors);//[ &#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;, &#39;yellow&#39; ]
</code></pre>
<blockquote>
<p>缺点：</p>
</blockquote>
<ol>
<li>通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享。</li>
<li>在创建子类型的实例时，没有办法在不影响所有对象实例的情况下给超类型的构造函数中传递参数。</li>
</ol>
<h4 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2. 借用构造函数"></a>2. 借用构造函数</h4><p><strong>借用构造函数</strong>的技术，其基本思想为:</p>
<p>在子类型的构造函数中调用超类型构造函数。</p>
<pre><code>functionSuperType(name) {
    this.name= name;
    this.colors= [&#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;];
}
functionSubType(name) {
    SuperType.call(this, name);
}
let instance1 =newSubType(&#39;Yvette&#39;);
instance1.colors.push(&#39;yellow&#39;);
console.log(instance1.colors);//[&#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;, yellow]let instance2 =newSubType(&#39;Jack&#39;);
console.log(instance2.colors); //[&#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;]
</code></pre>
<blockquote>
<p>优点:</p>
</blockquote>
<ol>
<li>可以向超类传递参数</li>
<li>解决了原型中包含引用类型值被所有实例共享的问题</li>
</ol>
<blockquote>
<p>缺点:</p>
</blockquote>
<ol>
<li>方法都在构造函数中定义，函数复用无从谈起，另外超类型原型中定义的方法对于子类型而言都是不可见的。</li>
</ol>
<h4 id="3-组合继承-原型链-借用构造函数"><a href="#3-组合继承-原型链-借用构造函数" class="headerlink" title="3. 组合继承(原型链 + 借用构造函数)"></a>3. 组合继承(原型链 + 借用构造函数)</h4><p>组合继承指的是将原型链和借用构造函数技术组合到一块，从而发挥二者之长的一种继承模式。基本思路：</p>
<p>使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。</p>
<pre><code>functionSuperType(name) {
    this.name= name;
    this.colors= [&#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;];
}
SuperType.prototype.sayName=function () {
    console.log(this.name);
}
functionSuberType(name, age) {
    SuperType.call(this, name);
    this.age= age;
}
SuberType.prototype=newSuperType();
SuberType.prototype.constructor= SuberType;
SuberType.prototype.sayAge=function () {
    console.log(this.age);
}
let instance1 =newSuberType(&#39;Yvette&#39;, 20);
instance1.colors.push(&#39;yellow&#39;);
console.log(instance1.colors); //[ &#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;, &#39;yellow&#39; ]instance1.sayName(); //Yvettelet instance2 =newSuberType(&#39;Jack&#39;, 22);
console.log(instance2.colors); //[ &#39;pink&#39;, &#39;blue&#39;, &#39;green&#39; ]instance2.sayName();//Jack
</code></pre>
<blockquote>
<p>缺点:</p>
</blockquote>
<ul>
<li>无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</li>
</ul>
<blockquote>
<p>优点:</p>
</blockquote>
<ul>
<li>可以向超类传递参数</li>
<li>每个实例都有自己的属性</li>
<li>实现了函数复用</li>
</ul>
<h4 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4. 原型式继承"></a>4. 原型式继承</h4><p>原型继承的基本思想：</p>
<p>借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。</p>
<pre><code>functionobject(o) {
    functionF() { }
    F.prototype= o;
    returnnewF();
}
</code></pre>
<p>在 <code>object()</code><br>函数内部，先穿甲一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例，从本质上讲，<code>object()</code><br>对传入的对象执行了一次浅拷贝。</p>
<p>ECMAScript5通过新增<br><code>Object.create()</code>方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象(可以覆盖原型对象上的同名属性)，在传入一个参数的情况下，<code>Object.create()</code><br>和 <code>object()</code> 方法的行为相同。</p>
<pre><code>var person = {
    name:&#39;Yvette&#39;,
    hobbies: [&#39;reading&#39;, &#39;photography&#39;]
}
var person1 =Object.create(person);
person1.name=&#39;Jack&#39;;
person1.hobbies.push(&#39;coding&#39;);
var person2 =Object.create(person);
person2.name=&#39;Echo&#39;;
person2.hobbies.push(&#39;running&#39;);
console.log(person.hobbies);//[ &#39;reading&#39;, &#39;photography&#39;, &#39;coding&#39;, &#39;running&#39; ]console.log(person1.hobbies);//[ &#39;reading&#39;, &#39;photography&#39;, &#39;coding&#39;, &#39;running&#39; ]
</code></pre>
<p>在没有必要创建构造函数，仅让一个对象与另一个对象保持相似的情况下，原型式继承是可以胜任的。</p>
<blockquote>
<p>缺点:</p>
</blockquote>
<p>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。</p>
<h4 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h4><p>寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>
<pre><code>functioncreateAnother(original) {
    var clone =object(original);//通过调用函数创建一个新对象clone.sayHi=function () {//以某种方式增强这个对象console.log(&#39;hi&#39;);
    };
    return clone;//返回这个对象
}
var person = {
    name:&#39;Yvette&#39;,
    hobbies: [&#39;reading&#39;, &#39;photography&#39;]
};

var person2 =createAnother(person);
person2.sayHi(); //hi
</code></pre>
<p>基于 <code>person</code> 返回了一个新对象 -—— <code>person2</code>，新对象不仅具有 <code>person</code> 的所有属性和方法，而且还有自己的 <code>sayHi()</code><br>方法。在考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。</p>
<blockquote>
<p>缺点：</p>
</blockquote>
<ul>
<li>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。</li>
<li>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。</li>
</ul>
<h4 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h4><p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，基本思路：</p>
<p>不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示：</p>
<pre><code>functioninheritPrototype(subType, superType) {
    var prototype =object(superType.prototype); //创建对象prototype.constructor= subType;//增强对象subType.prototype= prototype;//指定对象
}
</code></pre>
<ul>
<li>第一步：创建超类型原型的一个副本</li>
<li>第二步：为创建的副本添加 <code>constructor</code> 属性</li>
<li>第三步：将新创建的对象赋值给子类型的原型</li>
</ul>
<p>至此，我们就可以通过调用 <code>inheritPrototype</code> 来替换为子类型原型赋值的语句：</p>
<pre><code>functionSuperType(name) {
    this.name= name;
    this.colors= [&#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;];
}
//...codefunctionSuberType(name, age) {
    SuperType.call(this, name);
    this.age= age;
}
SuberType.prototype=newSuperType();
inheritPrototype(SuberType, SuperType);
//...code
</code></pre>
<blockquote>
<p>优点:</p>
</blockquote>
<p>只调用了一次超类构造函数，效率更高。避免在<code>SuberType.prototype</code>上面创建不必要的、多余的属性，与其同时，原型链还能保持不变。</p>
<p>因此寄生组合继承是引用类型最理性的继承范式。</p>
<h3 id="10-隐藏页面中的某个元素的方法有哪些？"><a href="#10-隐藏页面中的某个元素的方法有哪些？" class="headerlink" title="10. 隐藏页面中的某个元素的方法有哪些？"></a>10. 隐藏页面中的某个元素的方法有哪些？</h3><blockquote>
<p>隐藏类型</p>
</blockquote>
<p>屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类：</p>
<ul>
<li>完全隐藏：元素从渲染树中消失，不占据空间。</li>
<li>视觉上的隐藏：屏幕中不可见，占据空间。</li>
<li>语义上的隐藏：读屏软件不可读，但正常占据空。</li>
</ul>
<blockquote>
<p>完全隐藏</p>
</blockquote>
<h4 id="1-display-属性"><a href="#1-display-属性" class="headerlink" title="1.display 属性"></a>1.<code>display</code> 属性</h4><pre><code>display: none;
</code></pre>
<h4 id="2-hidden-属性"><a href="#2-hidden-属性" class="headerlink" title="2.hidden 属性"></a>2.hidden 属性</h4><p>HTML5 新增属性，相当于 <code>display: none</code></p>
<pre><code>&lt;divhidden&gt;
&lt;/div&gt;
</code></pre>
<blockquote>
<p>视觉上的隐藏</p>
</blockquote>
<h4 id="1-利用-position-和-盒模型-将元素移出可视区范围"><a href="#1-利用-position-和-盒模型-将元素移出可视区范围" class="headerlink" title="1.利用 position 和 盒模型 将元素移出可视区范围"></a>1.利用 <code>position</code> 和 盒模型 将元素移出可视区范围</h4><ol>
<li><p>设置 <code>posoition</code> 为 <code>absolute</code> 或 <code>fixed</code>，�通过设置 <code>top</code>、<code>left</code> 等值，将其移出可视区域。</p>
<p> position:absolute;<br> left: -99999px;</p>
</li>
<li><p>设置 <code>position</code> 为 <code>relative</code>，通过设置 <code>top</code>、<code>left</code> 等值，将其移出可视区域。</p>
<p> position: relative;<br> left: -99999px;<br> height: 0</p>
</li>
<li><p>设置 margin 值，将其移出可视区域范围（可视区域占位）。</p>
<p> margin-left: -99999px;<br> height: 0;</p>
</li>
</ol>
<h4 id="2-利用-transfrom"><a href="#2-利用-transfrom" class="headerlink" title="2.利用 transfrom"></a>2.利用 transfrom</h4><ol>
<li><p>缩放</p>
<p> transform: scale(0);<br> height: 0;</p>
</li>
<li><p>移动 <code>translateX</code>, <code>translateY</code></p>
<p> transform: translateX(-99999px);<br> height: 0</p>
</li>
<li><p>旋转 <code>rotate</code></p>
<p> transform: rotateY(90deg);</p>
</li>
</ol>
<h4 id="3-设置其大小为0"><a href="#3-设置其大小为0" class="headerlink" title="3.设置其大小为0"></a>3.设置其大小为0</h4><ol>
<li><p>宽高为0，字体大小为0：</p>
<p> height: 0;<br> width: 0;<br> font-size: 0;</p>
</li>
<li><p>宽高为0，超出隐藏:</p>
<p> height: 0;<br> width: 0;<br> overflow: hidden;</p>
</li>
</ol>
<h4 id="4-设置透明度为0"><a href="#4-设置透明度为0" class="headerlink" title="4.设置透明度为0"></a>4.设置透明度为0</h4><pre><code>opacity: 0;
</code></pre>
<h4 id="5-visibility属性"><a href="#5-visibility属性" class="headerlink" title="5.visibility属性"></a>5.<code>visibility</code>属性</h4><pre><code>visibility: hidden;
</code></pre>
<h4 id="6-层级覆盖，z-index-属性"><a href="#6-层级覆盖，z-index-属性" class="headerlink" title="6.层级覆盖，z-index 属性"></a>6.层级覆盖，<code>z-index</code> 属性</h4><pre><code>position: relative;
z-index: -999;
</code></pre>
<p>再设置一个层级较高的元素覆盖在此元素上。</p>
<h4 id="7-clip-path-裁剪"><a href="#7-clip-path-裁剪" class="headerlink" title="7.clip-path 裁剪"></a>7.clip-path 裁剪</h4><pre><code>clip-path: polygon(0 0, 0 0, 0 0, 0 0);
</code></pre>
<blockquote>
<p>语义上的隐藏</p>
</blockquote>
<h4 id="aria-hidden-属性"><a href="#aria-hidden-属性" class="headerlink" title="aria-hidden 属性"></a>aria-hidden 属性</h4><p>读屏软件不可读，占据空间，可见。</p>
<pre><code>&lt;divaria-hidden=&quot;true&quot;&gt;
&lt;/div&gt;
</code></pre>
<h3 id="11-let、const、var-的区别有哪些？"><a href="#11-let、const、var-的区别有哪些？" class="headerlink" title="11. let、const、var 的区别有哪些？"></a>11. let、const、var 的区别有哪些？</h3><p>声明方式变量提升暂时性死区重复声明块作用域有效初始值重新赋值var会不存在允许不是非必须允许let不会存在不允许是非必须允许const不会存在不允许是必须不允许<br>1.let&#x2F;const 定义的变量不会出现变量提升，而 var 定义的变量会提升。</p>
<p>2.相同作用域中，let 和 const 不允许重复声明，var 允许重复声明。</p>
<p>3.const 声明变量时必须设置初始值</p>
<p>4.const 声明一个只读的常量，这个常量不可改变。</p>
<p>这里有一个非常重要的点即是：在JS中，复杂数据类型，存储在栈中的是堆内存的地址，存在栈中的这个地址是不变的，但是存在堆中的值是可以变得。有没有相当常量指针&#x2F;指针常量~</p>
<pre><code>consta=20;
constb= {
    age:18,
    star:500
}
</code></pre>
<p>一图胜万言，如下图所示，不变的是栈内存中 a 存储的 20，和 b 中存储的 0x0012ff21（瞎编的一个数字）。而 {age: 18, star:<br>200} 是可变的。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/ed02c1af72d4c8780f57b43c364caedfadba0516/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f7075626c69632f7265736f757263652f66343537303163633431303530346537316462626362643838363165386430632f786d6c6e6f74652f5745425245534f5552434530383735656138663831633231306165393363653631396335663964386232642f3239343733"><img src="https://camo.githubusercontent.com/ed02c1af72d4c8780f57b43c364caedfadba0516/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f7075626c69632f7265736f757263652f66343537303163633431303530346537316462626362643838363165386430632f786d6c6e6f74652f5745425245534f5552434530383735656138663831633231306165393363653631396335663964386232642f3239343733" alt="xuehuayu.cn"></a></p>
<h3 id="12-说一说你对JS执行上下文栈和作用域链的理解？"><a href="#12-说一说你对JS执行上下文栈和作用域链的理解？" class="headerlink" title="12. 说一说你对JS执行上下文栈和作用域链的理解？"></a>12. 说一说你对JS执行上下文栈和作用域链的理解？</h3><p>在开始说明JS上下文栈和作用域之前，我们先说明下JS上下文以及作用域的概念。</p>
<h4 id="JS执行上下文"><a href="#JS执行上下文" class="headerlink" title="JS执行上下文"></a><a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/?nsukey=rQHqMrFpKq6JJN//OeubPCslaSTSRyuc/XCznnIDze1SGzwva5SZtzixJ13p2gAlxua95Xa7fraZXwj5tyLRDK33+pNhyfKR/xyzhWNyB/qaIlsDGyQBckNoHQGPveOB24M+cK/gF8Tg1ehUGLWiCvumxdgcQwZOWj2BGfD3n/Y=#sec-execution-contexts">JS执行上下文</a></h4><p>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。</p>
<blockquote>
<p>执行上下文类型分为：</p>
</blockquote>
<ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
</ul>
<p>执行上下文创建过程中，需要做以下几件事:</p>
<ol>
<li>创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。</li>
<li>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。</li>
<li>确定this的值，即 ResolveThisBinding</li>
</ol>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p><strong>作用域</strong>负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。——<br>摘录自《你不知道的JavaScript》(上卷)</p>
<p>作用域有两种工作模型：词法作用域和动态作用域，JS采用的是<strong>词法作用域</strong>工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。(<code>with</code><br>和 <code>eval</code> 能够修改词法作用域，但是不推荐使用，对此不做特别说明)</p>
<blockquote>
<p>作用域分为：</p>
</blockquote>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域</li>
</ul>
<h4 id="JS执行上下文栈-后面简称执行栈"><a href="#JS执行上下文栈-后面简称执行栈" class="headerlink" title="JS执行上下文栈(后面简称执行栈)"></a>JS执行上下文栈(后面简称执行栈)</h4><p>执行栈，也叫做调用栈，具有 <strong>LIFO</strong> (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。</p>
<blockquote>
<p>规则如下：</p>
</blockquote>
<ul>
<li></li>
</ul>
<p>首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。</p>
<ul>
<li>当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。</li>
</ul>
<p>以一段代码具体说明：</p>
<pre><code>functionfun3() {
    console.log(&#39;fun3&#39;)
}

functionfun2() {
    fun3();
}

functionfun1() {
    fun2();
}

fun1();
</code></pre>
<p><code>Global Execution Context</code> (即全局执行上下文)首先入栈，过程如下：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/91e9dd3b5bb10580e674c7a6dc6a0e23bd6a4412/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f7075626c69632f7265736f757263652f66343537303163633431303530346537316462626362643838363165386430632f786d6c6e6f74652f5745425245534f5552434536396264626461313461663038663333363831666563613032313665336239622f3239343435"><img src="https://camo.githubusercontent.com/91e9dd3b5bb10580e674c7a6dc6a0e23bd6a4412/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f7075626c69632f7265736f757263652f66343537303163633431303530346537316462626362643838363165386430632f786d6c6e6f74652f5745425245534f5552434536396264626461313461663038663333363831666563613032313665336239622f3239343435" alt="xuehuayu.cn"></a></p>
<p>伪代码:</p>
<pre><code>//全局执行上下文首先入栈ECStack.push(globalContext);

//执行fun1();ECStack.push(&lt;fun1&gt; functionContext);

//fun1中又调用了fun2;ECStack.push(&lt;fun2&gt; functionContext);

//fun2中又调用了fun3;ECStack.push(&lt;fun3&gt; functionContext);

//fun3执行完毕ECStack.pop();

//fun2执行完毕ECStack.pop();

//fun1执行完毕ECStack.pop();

//javascript继续顺序执行下面的代码，但ECStack底部始终有一个 全局上下文（globalContext）;
</code></pre>
<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。</p>
<p>如：</p>
<pre><code>var a =10;
functionfn1() {
    var b =20;
    console.log(fn2)
    functionfn2() {
        a =20
    }
    return fn2;
}
fn1()();
</code></pre>
<p>fn2作用域链 &#x3D; [fn2作用域, fn1作用域，全局作用域]</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/67d8d95ca5726d90408b24ed9cf01ccbef32e769/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f7075626c69632f7265736f757263652f66343537303163633431303530346537316462626362643838363165386430632f786d6c6e6f74652f5745425245534f5552434531363630373963303963636534376633636164363632386539326137373434362f3239343339"><img src="https://camo.githubusercontent.com/67d8d95ca5726d90408b24ed9cf01ccbef32e769/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f7075626c69632f7265736f757263652f66343537303163633431303530346537316462626362643838363165386430632f786d6c6e6f74652f5745425245534f5552434531363630373963303963636534376633636164363632386539326137373434362f3239343339" alt="xuehuayu.cn"></a></p>
<h3 id="13-防抖函数的作用是什么？请实现一个防抖函数"><a href="#13-防抖函数的作用是什么？请实现一个防抖函数" class="headerlink" title="13. 防抖函数的作用是什么？请实现一个防抖函数"></a>13. 防抖函数的作用是什么？请实现一个防抖函数</h3><blockquote>
<p>防抖函数的作用</p>
</blockquote>
<p>防抖函数的作用就是控制函数在一定时间内的执行次数。防抖意味着N秒内函数只会被执行一次，如果N秒内再次被触发，则<strong>重新</strong>计算延迟时间。</p>
<p><strong>举例说明：</strong><br>小思最近在减肥，但是她非常吃吃零食。为此，与其男朋友约定好，如果10天不吃零食，就可以购买一个包(不要问为什么是包，因为<strong>包治百病</strong>)。但是如果中间吃了一次零食，那么就要重新计算时间，直到小思坚持10天没有吃零食，才能购买一个包。所以，管不住嘴的小思，没有机会买包(悲伤的故事)…<br>这就是 <strong>防抖</strong>。</p>
<blockquote>
<p>防抖函数实现</p>
</blockquote>
<ol>
<li><p>事件第一次触发时，<code>timer</code> 是 <code>null</code>，调用 <code>later()</code>，若 <code>immediate</code> 为<code>true</code>，那么立即调用<br><code>func.apply(this, params)</code>；如果 <code>immediate</code> 为 <code>false</code>，那么过 <code>wait</code> 之后，调用<br><code>func.apply(this, params)</code></p>
</li>
<li><p>事件第二次触发时，如果 <code>timer</code> 已经重置为 <code>null</code>(即 <code>setTimeout</code> 的倒计时结束)，那么流程与第一次触发时一样，若<br><code>timer</code> 不为 <code>null</code>(即 setTimeout 的倒计时未结束)，那么清空定时器，重新开始计时。</p>
<p> functiondebounce(func, wait, immediate&#x3D;true) {<br> let timeout, result;<br> &#x2F;&#x2F; 延迟执行函数constlater&#x3D; (context, args) &#x3D;&gt;setTimeout(() &#x3D;&gt; {<br>     timeout &#x3D;null;&#x2F;&#x2F; 倒计时结束if (!immediate) {<br>         &#x2F;&#x2F;执行回调<br>         result &#x3D;func.apply(context, args);<br>         context &#x3D; args &#x3D;null;<br>     }<br> }, wait);<br> letdebounced&#x3D;function (…params) {<br>     if (!timeout) {<br>         timeout &#x3D;later(this, params);<br>         if (immediate) {<br>             &#x2F;&#x2F;立即执行<br>             result &#x3D;func.apply(this, params);<br>         }<br>     } else {<br>         clearTimeout(timeout);<br>         &#x2F;&#x2F;函数在每个等待时延的结束被调用<br>         timeout &#x3D;later(this, params);<br>     }<br>     return result;<br> }<br> &#x2F;&#x2F;提供在外部清空定时器的方法debounced.cancel&#x3D;function () {<br>     clearTimeout(timer);<br>     timer &#x3D;null;<br> };<br> return debounced;<br> };</p>
</li>
</ol>
<p><code>immediate</code> 为 true 时，表示函数在每个等待时延的开始被调用。<code>immediate</code> 为 false 时，表示函数在每个等待时延的结束被调用。</p>
<blockquote>
<p>防抖的应用场景</p>
</blockquote>
<ol>
<li>搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。</li>
<li>表单验证</li>
<li>按钮提交事件。</li>
<li>浏览器窗口缩放，resize事件(如窗口停止改变大小之后重新计算布局)等。</li>
</ol>
<h3 id="14-节流函数的作用是什么？有哪些应用场景，请实现一个节流函数"><a href="#14-节流函数的作用是什么？有哪些应用场景，请实现一个节流函数" class="headerlink" title="14. 节流函数的作用是什么？有哪些应用场景，请实现一个节流函数"></a>14. 节流函数的作用是什么？有哪些应用场景，请实现一个节流函数</h3><blockquote>
<p>节流函数的作用</p>
</blockquote>
<p>节流函数的作用是规定一个单位时间，在这个单位时间内最多只能触发一次函数执行，如果这个单位时间内多次触发函数，只能有一次生效。</p>
<blockquote>
<p>节流函数实现</p>
</blockquote>
<pre><code>functionthrottle(func, wait, options= {}) {
    var timeout, context, args, result;
    var previous =0;
    varlater=function () {
        previous =options.leading===false?0: (Date.now() ||newDate().getTime());
        timeout =null;
        result =func.apply(context, args);
        if (!timeout) context = args =null;
    };

    varthrottled=function () {
        var now =Date.now() ||newDate().getTime();
        if (!previous &amp;&amp;options.leading===false) previous = now;
        //remaining 为距离下次执行 func 的时间//remaining &gt; wait，表示客户端系统时间被调整过var remaining = wait - (now - previous);
        context =this;
        args =arguments;
        //remaining 小于等于0，表示事件触发的间隔时间大于设置的 waitif (remaining &lt;=0|| remaining &gt; wait) {
            if (timeout) {
                //清空定时器clearTimeout(timeout);
                timeout =null;
            }
            //重置 previous
            previous = now;
            //执行函数
            result =func.apply(context, args);
            if (!timeout) context = args =null;
        } elseif (!timeout &amp;&amp;options.trailing!==false) {
            timeout =setTimeout(later, remaining);
        }
        return result;
    };

    throttled.cancel=function () {
        clearTimeout(timeout);
        previous =0;
        timeout = context = args =null;
    };

    return throttled;
}
</code></pre>
<p>禁用第一次首先执行，传递 <code>{leading: false}</code> ；想禁用最后一次执行，传递 <code>{trailing: false}</code></p>
<blockquote>
<p>节流的应用场景</p>
</blockquote>
<ol>
<li>按钮点击事件</li>
<li>拖拽事件</li>
<li>onScoll</li>
<li>计算鼠标移动的距离(mousemove)</li>
</ol>
<h3 id="15-什么是闭包？闭包的作用是什么？"><a href="#15-什么是闭包？闭包的作用是什么？" class="headerlink" title="15. 什么是闭包？闭包的作用是什么？"></a>15. 什么是闭包？闭包的作用是什么？</h3><h4 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h4><p>《JavaScript高级程序设计》:</p>
<blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数</p>
</blockquote>
<p>《JavaScript权威指南》：</p>
<blockquote>
<p>从技术的角度讲，所有的JavaScript函数都是闭包：它们都是对象，它们都关联到作用域链。</p>
</blockquote>
<p>《你不知道的JavaScript》</p>
<blockquote>
<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p>
</blockquote>
<h4 id="创建一个闭包"><a href="#创建一个闭包" class="headerlink" title="创建一个闭包"></a>创建一个闭包</h4><pre><code>functionfoo() {
    var a =2;
    returnfunctionfn() {
        console.log(a);
    }
}
let func =foo();
func(); //输出2
</code></pre>
<p>闭包使得函数可以继续访问定义时的词法作用域。拜 fn 所赐，在 foo() 执行后，foo 内部作用域不会被销毁。</p>
<h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4><ol>
<li><p>能够访问函数定义时所在的词法作用域(阻止其被回收)。</p>
</li>
<li><p>私有化变量</p>
<p> functionbase() {<br> let x &#x3D;10; &#x2F;&#x2F;私有变量return {<br>     getX:function() {<br>         return x;<br>     }<br> }<br> }<br> let obj &#x3D;base();<br> console.log(obj.getX()); &#x2F;&#x2F;10</p>
</li>
<li><p>模拟块级作用域</p>
<p> var a &#x3D; [];<br> for (var i &#x3D;0; i &lt;10; i++) {<br> a[i] &#x3D; (function(j){<br>     returnfunction () {<br>         console.log(j);<br>     }<br> })(i);<br> }<br> a<a href="">6</a>; &#x2F;&#x2F; 6</p>
</li>
<li><p>创建模块</p>
<p> functioncoolModule() {<br> let name &#x3D;’Yvette’;<br> let age &#x3D;20;<br> functionsayName() {<br>     console.log(name);<br> }<br> functionsayAge() {<br>     console.log(age);<br> }<br> return {<br>     sayName,<br>     sayAge<br> }<br> }<br> let info &#x3D;coolModule();<br> info.sayName(); &#x2F;&#x2F;‘Yvette’</p>
</li>
</ol>
<p>模块模式具有两个必备的条件(来自《你不知道的JavaScript》)</p>
<ul>
<li>必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)</li>
<li>封闭函数必须返回至少<strong>一个</strong>内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li>
</ul>
<h3 id="16-实现-Promise-all-方法"><a href="#16-实现-Promise-all-方法" class="headerlink" title="16. 实现 Promise.all 方法"></a>16. 实现 Promise.all 方法</h3><p>在实现 Promise.all 方法之前，我们首先要知道 Promise.all 的功能和特点，因为在清楚了 Promise.all<br>功能和特点的情况下，我们才能进一步去写实现。</p>
<blockquote>
<p>Promise.all 功能</p>
</blockquote>
<p><code>Promise.all(iterable)</code> 返回一个新的 Promise 实例。此实例在 <code>iterable</code> 参数内所有的 <code>promise</code> 都<br><code>fulfilled</code> 或者参数中不包含 <code>promise</code> 时，状态变成 <code>fulfilled</code>；如果参数中 <code>promise</code><br>有一个失败<code>rejected</code>，此实例回调失败，失败原因的是第一个失败 <code>promise</code> 的返回结果。</p>
<pre><code>let p =Promise.all([p1, p2, p3]);
</code></pre>
<p>p的状态由 p1,p2,p3决定，分成以下；两种情况：</p>
<p>（1）只有p1、p2、p3的状态都变成 <code>fulfilled</code>，p的状态才会变成<br><code>fulfilled</code>，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p>
<p>（2）只要p1、p2、p3之中有一个被 <code>rejected</code>，p的状态就变成<br><code>rejected</code>，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p>
<blockquote>
<p>Promise.all 的特点</p>
</blockquote>
<p>Promise.all 的返回值是一个 promise 实例</p>
<ul>
<li>如果传入的参数为空的可迭代对象，<code>Promise.all</code> 会 <strong>同步</strong> 返回一个已完成状态的 <code>promise</code></li>
<li>如果传入的参数中不包含任何 promise,<code>Promise.all</code> 会 <strong>异步</strong> 返回一个已完成状态的 <code>promise</code></li>
<li>其它情况下，<code>Promise.all</code> 返回一个 <strong>处理中（pending）</strong> 状态的 <code>promise</code>.</li>
</ul>
<blockquote>
<p>Promise.all 返回的 promise 的状态</p>
</blockquote>
<ul>
<li>如果传入的参数中的 promise 都变成完成状态，<code>Promise.all</code> 返回的 <code>promise</code> 异步地变为完成。</li>
<li>如果传入的参数中，有一个 <code>promise</code> 失败，<code>Promise.all</code> 异步地将失败的那个结果给失败状态的回调函数，而不管其它 <code>promise</code></li>
</ul>
<p>是否完成</p>
<ul>
<li>在任何情况下，<code>Promise.all</code> 返回的 <code>promise</code> 的完成状态的结果都是一个数组</li>
</ul>
<blockquote>
<p>Promise.all 实现</p>
</blockquote>
<pre><code>Promise.all=function (promises) {
    //promises 是可迭代对象，省略参数合法性检查returnnewPromise((resolve, reject) =&gt; {
        //Array.from 将可迭代对象转换成数组
        promises =Array.from(promises);
        if (promises.length===0) {
            resolve([]);
        } else {
            let result = [];
            let index =0;
            for (let i =0;  i &lt;promises.length; i++ ) {
                //考虑到 i 可能是 thenable 对象也可能是普通值Promise.resolve(promises[i]).then(data=&gt; {
                    result[i] = data;
                    if (++index ===promises.length) {
                        //所有的 promises 状态都是 fulfilled，promise.all返回的实例才变成 fulfilled 态resolve(result);
                    }
                }, err=&gt; {
                    reject(err);
                    return;
                });
            }
        }
    });
}
</code></pre>
<h3 id="17-请实现一个-flattenDeep-函数，把嵌套的数组扁平化"><a href="#17-请实现一个-flattenDeep-函数，把嵌套的数组扁平化" class="headerlink" title="17. 请实现一个 flattenDeep 函数，把嵌套的数组扁平化"></a>17. 请实现一个 flattenDeep 函数，把嵌套的数组扁平化</h3><p>例如:</p>
<pre><code>flattenDeep([1, [2, [3, [4]], 5]]); //[1, 2, 3, 4, 5]
</code></pre>
<blockquote>
<p>利用 Array.prototype.flat</p>
</blockquote>
<p>ES6 为数组实例新增了 <code>flat</code> 方法，用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数组没有影响。</p>
<p><code>flat</code> 默认只会 “拉平” 一层，如果想要 “拉平” 多层的嵌套数组，需要给 <code>flat</code> 传递一个整数，表示想要拉平的层数。</p>
<pre><code>functionflattenDeep(arr, deepLength) {
    returnarr.flat(deepLength);
}
console.log(flattenDeep([1, [2, [3, [4]], 5]], 3));
</code></pre>
<p>当传递的整数大于数组嵌套的层数时，会将数组拉平为一维数组，JS能表示的最大数字为 <code>Math.pow(2, 53) - 1</code>，因此我们可以这样定义<br><code>flattenDeep</code> 函数</p>
<pre><code>functionflattenDeep(arr) {
    //当然，大多时候我们并不会有这么多层级的嵌套returnarr.flat(Math.pow(2,53) -1);
}
console.log(flattenDeep([1, [2, [3, [4]], 5]]));
</code></pre>
<blockquote>
<p>利用 reduce 和 concat</p>
</blockquote>
<pre><code>functionflattenDeep(arr){
    returnarr.reduce((acc, val) =&gt;Array.isArray(val) ?acc.concat(flattenDeep(val)) :acc.concat(val), []);
}
console.log(flattenDeep([1, [2, [3, [4]], 5]]));
</code></pre>
<blockquote>
<p>使用 stack 无限反嵌套多层嵌套数组</p>
</blockquote>
<pre><code>functionflattenDeep(input) {
    conststack= [...input];
    constres= [];
    while (stack.length) {
        // 使用 pop 从 stack 中取出并移除值constnext=stack.pop();
        if (Array.isArray(next)) {
            // 使用 push 送回内层数组中的元素，不会改动原始输入 original inputstack.push(...next);
        } else {
            res.push(next);
        }
    }
    // 使用 reverse 恢复原数组的顺序returnres.reverse();
}
console.log(flattenDeep([1, [2, [3, [4]], 5]]));
</code></pre>
<h3 id="18-请实现一个-uniq-函数，实现数组去重"><a href="#18-请实现一个-uniq-函数，实现数组去重" class="headerlink" title="18. 请实现一个 uniq 函数，实现数组去重"></a>18. 请实现一个 uniq 函数，实现数组去重</h3><p>例如:</p>
<pre><code>uniq([1, 2, 3, 5, 3, 2]);//[1, 2, 3, 5]
</code></pre>
<blockquote>
<p>法1: 利用ES6新增数据类型 <code>Set</code></p>
</blockquote>
<p><code>Set</code>类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<pre><code>functionuniq(arry) {
    return [...newSet(arry)];
}
</code></pre>
<blockquote>
<p>法2: 利用 <code>indexOf</code></p>
</blockquote>
<pre><code>functionuniq(arry) {
    var result = [];
    for (var i =0; i &lt;arry.length; i++) {
        if (result.indexOf(arry[i]) ===-1) {
            //如 result 中没有 arry[i],则添加到数组中result.push(arry[i])
        }
    }
    return result;
}
</code></pre>
<blockquote>
<p>法3: 利用 <code>includes</code></p>
</blockquote>
<pre><code>functionuniq(arry) {
    var result = [];
    for (var i =0; i &lt;arry.length; i++) {
        if (!result.includes(arry[i])) {
            //如 result 中没有 arry[i],则添加到数组中result.push(arry[i])
        }
    }
    return result;
}
</code></pre>
<blockquote>
<p>法4：利用 <code>reduce</code></p>
</blockquote>
<pre><code>functionuniq(arry) {
    returnarry.reduce((prev, cur) =&gt;prev.includes(cur) ? prev : [...prev, cur], []);
}
</code></pre>
<blockquote>
<p>法5：利用 <code>Map</code></p>
</blockquote>
<pre><code>functionuniq(arry) {
    let map =newMap();
    let result =newArray();
    for (let i =0; i &lt;arry.length; i++) {
        if (map.has(arry[i])) {
            map.set(arry[i], true);
        } else {
            map.set(arry[i], false);
            result.push(arry[i]);
        }
    }
    return result;
}
</code></pre>
<h3 id="19-可迭代对象有哪些特点"><a href="#19-可迭代对象有哪些特点" class="headerlink" title="19. 可迭代对象有哪些特点"></a>19. 可迭代对象有哪些特点</h3><p>ES6 规定，默认的 <code>Iterator</code> 接口部署在数据结构的 <code>Symbol.iterator</code> 属性，换个角度，也可以认为，一个数据结构只要具有<br><code>Symbol.iterator</code> 属性(<code>Symbol.iterator</code> 方法对应的是遍历器生成函数，返回的是一个遍历器对象)，那么就可以其认为是可迭代的。</p>
<h4 id="可迭代对象的特点"><a href="#可迭代对象的特点" class="headerlink" title="可迭代对象的特点"></a>可迭代对象的特点</h4><ul>
<li><p>具有 <code>Symbol.iterator</code> 属性，<code>Symbol.iterator()</code> 返回的是一个遍历器对象</p>
</li>
<li><p>可以使用 <code>for ... of</code> 进行循环</p>
</li>
<li><p>通过被 <code>Array.from</code> 转换为数组</p>
<p>  let arry &#x3D; [1, 2, 3, 4];<br>  let iter &#x3D; arry<a href="">Symbol.iterator</a>;<br>  console.log(iter.next()); &#x2F;&#x2F;{ value: 1, done: false }console.log(iter.next()); &#x2F;&#x2F;{ value: 2, done: false }console.log(iter.next()); &#x2F;&#x2F;{ value: 3, done: false }</p>
</li>
</ul>
<h4 id="原生具有-Iterator-接口的数据结构："><a href="#原生具有-Iterator-接口的数据结构：" class="headerlink" title="原生具有 Iterator 接口的数据结构："></a>原生具有 <code>Iterator</code> 接口的数据结构：</h4><ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<h3 id="20-JSONP-的原理是什么？"><a href="#20-JSONP-的原理是什么？" class="headerlink" title="20. JSONP 的原理是什么？"></a>20. JSONP 的原理是什么？</h3><p>尽管浏览器有同源策略，但是 <code>&lt;script&gt;</code> 标签的 <code>src</code> 属性不会被同源策略所约束，可以获取任意服务器上的脚本并执行。<code>jsonp</code> 通过插入<br><code>script</code> 标签的方式来实现跨域，参数只能通过 <code>url</code> 传入，仅能支持 <code>get</code> 请求。</p>
<blockquote>
<p>实现原理:</p>
</blockquote>
<ul>
<li>Step1: 创建 callback 方法</li>
<li>Step2: 插入 script 标签</li>
<li>Step3: 后台接受到请求，解析前端传过去的 callback 方法，返回该方法的调用，并且数据作为参数传入该方法</li>
<li>Step4: 前端执行服务端返回的方法调用</li>
</ul>
<blockquote>
<p>jsonp源码实现</p>
</blockquote>
<pre><code>functionjsonp({url, params, callback}) {
    returnnewPromise((resolve, reject) =&gt; {
        //创建script标签let script =document.createElement(&#39;script&#39;);
        //将回调函数挂在 window 上window[callback] =function(data) {
            resolve(data);
            //代码执行后，删除插入的script标签document.body.removeChild(script);
        }
        //回调函数加在请求地址上
        params = {...params, callback} //wb=b&amp;callback=showlet arrs = [];
        for(let key in params) {
            arrs.push(`${key}=${params[key]}`);
        }
        script.src=`${url}?${arrs.join(&#39;&amp;&#39;)}`;
        document.body.appendChild(script);
    });
}
</code></pre>
<blockquote>
<p>使用:</p>
</blockquote>
<pre><code>functionshow(data) {
    console.log(data);
}
jsonp({
    url:&#39;http://localhost:3000/show&#39;,
    params: {
        //code
    },
    callback:&#39;show&#39;
}).then(data=&gt; {
    console.log(data);
});
</code></pre>
<blockquote>
<p>服务端代码(node):</p>
</blockquote>
<pre><code>//express启动一个后台服务let express =require(&#39;express&#39;);
let app =express();

app.get(&#39;/show&#39;, (req, res) =&gt; {
    let {callback} =req.query; //获取传来的callback函数名，callback是keyres.send(`${callback}(&#39;Hello!&#39;)`);
});
app.listen(3000);
</code></pre>
<h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><p>[1] <a target="_blank" rel="noopener" href="http://www.zhufengpeixun.cn/main/course/index.html">珠峰架构课(墙裂推荐)</a></p>
<p>[2] [JavaScript高级程序设计第六章]</p>
<p>[3] <a target="_blank" rel="noopener" href="https://juejin.im/post/5cea6e5fe51d45775e33f4de">Step-By-Step】高频面试题深入解析 &#x2F;<br>周刊01</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://juejin.im/post/5cf392e75188250d2850f97d">Step-By-Step】高频面试题深入解析 &#x2F;<br>周刊02</a></p>
<p>[5] <a target="_blank" rel="noopener" href="https://juejin.im/post/5cfdc5c7f265da1b8a4f10f3">Step-By-Step】高频面试题深入解析 &#x2F;<br>周刊03</a></p>
<p>[6] <a target="_blank" rel="noopener" href="https://juejin.im/post/5d064ab851882510715e37ad">Step-By-Step】高频面试题深入解析 &#x2F;<br>周刊04</a></p>
<p>谢谢各位小伙伴愿意花费宝贵的时间阅读本文，如果本文给了您一点帮助或者是启发，请不要吝啬你的赞和Star，您的肯定是我前进的最大动力。<br><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Blog">https://github.com/YvetteLau/Blog</a></p>
</div><iframe src="/donate/?AliPayQR=/img/AliPayQR.png&amp;WeChatQR=/img/WeChatQR.png&amp;UnionPayQR=null&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=https://paypal.me/BigOldTwo&amp;afd=https://ifdian.net/order/create?user_id=1f326f88329e11eeb16752540025c377" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>搬砖大老</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/article/c3a5c18.html">https://xuehuayu.cn/article/c3a5c18.html</a></li><li class="post-copyright-license"><strong>版权声明：</strong>① 标为原创的文章为博主原创，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接。② 部分文章内容由 AI 生成，内容仅供参考，请仔细甄别。③ 标为转载的文章来自网络，已标明出处，<a href="mailto:boss@xuehuayu.cn">侵删</a>。</li></ul></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/article/356e7afa.html">精读《最佳前端面试题》及面试官技巧</a><a class="next" href="/article/c1f2b7c5.html">高频面试题深入解析 / 周刊 01</a></div><div id="waline-comment"></div><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@waline/client@v2/dist/waline.min.css"><script src="//cdn.jsdelivr.net/npm/@waline/client@v2/dist/waline.min.js"></script><script>const origin = window.location.origin
const serverURL = origin.includes('cainiaoblog') ? 'https://guest.cainiaoblog.cn' : 'https://guest.xuehuayu.cn'
const locale = {
  placeholder: '请正确填写昵称和邮箱，方便接收回复通知~',
  sofa: '沙发空缺中，还不快抢~',
  admin: '管理员'
};
Waline.init({
  el: '#waline-comment',
  serverURL: serverURL,
  locale,
  pageSize: '20',
  visitor: false == true, // 阅读量统计
  requiredMeta: ['nick', 'mail'],
  pageview: true,
  reaction: true,
  emoji: [
    '//cdn.jsdelivr.net/npm/@waline/emojis@1.2.0/qq',
    '//cdn.jsdelivr.net/npm/@waline/emojis@1.2.0/bmoji',
    '//cdn.jsdelivr.net/npm/@waline/emojis@1.2.0/weibo',
    '//cdn.jsdelivr.net/npm/@waline/emojis@1.2.0/tieba',
    '//cdn.jsdelivr.net/npm/@waline/emojis@1.2.0/tw-emoji',
    '//cdn.jsdelivr.net/npm/@waline/emojis@1.2.0/alus',
    '//cdn.jsdelivr.net/npm/@waline/emojis@1.2.0/bilibili',
    '//cdn.jsdelivr.net/npm/@waline/emojis@1.2.0/soul-emoji'
  ],
})</script></div></div></div><div class="pure-u-1 pure-u-md-1-4 fixed-search hidden_mid_and_down"><div id="sidebar"><script type="text/javascript" src="/js/search.js"></script><div class="widget widget-all-search"><div class="widget-search"><input class="search" type="radio" name="search" value="baidu" id="baidu" checked="checked"/><label class="label" for="baidu" title="百度全站搜索">百度</label><input class="search" type="radio" name="search" value="google" id="google"/><label class="label" for="google" title="谷歌全站搜索">谷歌</label><input class="search" type="radio" name="search" value="self" id="self"/><label class="label" for="self" title="使用站内搜索">站内</label></div><div class="widget" id="search"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="30" placeholder="百度全站搜索"/><input type="hidden" name="si" value="xuehuayu.cn"/><input type="hidden" name="cl" value="3"/><input type="hidden" name="ct" value="2097152"/><input type="hidden" name="s" value="on"/><input class="search-submit" type="submit" value=""/></form></div></div><script>$('input[type=radio][name=search]').change(function() {
  var val = $(this).val()
  var self = '<div class="search-form"><input id="local-search-input" placeholder="站内搜索，首次慢" type="search" name="q" results="0"><input class="search-submit" type="submit" value=""/><div id="local-search-result"></div></div>'
  var google = '<form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="q" maxlength="30" placeholder="谷歌全站搜索"><input type="hidden" name="sitesearch" value="xuehuayu.cn"><input class="search-submit" type="submit" value=""/></form>'
  var baidu = '<form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="30" placeholder="百度全站搜索"><input type="hidden" name="si" value="xuehuayu.cn"><input type="hidden" name="cl" value="3"><input type="hidden" name="ct" value="2097152"><input type="hidden" name="s" value="on"><input class="search-submit" type="submit" value=""/></form>'

  if (val === 'self') {
      $('#search').html(self)
      var search_path = 'search.xml';
      if (search_path.length == 0) {
        search_path = '//search.xml';
      }
      var path = '/' + search_path;
      searchFunc(path, 'local-search-input', 'local-search-result');
  } else if (val === 'baidu') {
      $('#search').html(baidu)
  } else if (val === 'google') {
      $('#search').html(google)
  }
})</script><div class="widget widget-wxmp"><img alt="微信公众号" width="100%" src="/img/mp-mini.png"/></div><div class="widget widget-recent-posts"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/article/ead1a366.html">vue3 pinia在App.vue中使用了useStore报错getActivePinia() was called but there wa no active pinia</a></li><li class="post-list-item"><a class="post-list-link" href="/article/abe47f31.html">vue3中的mixin写法使用Composition API 来实现代码复用</a></li><li class="post-list-item"><a class="post-list-link" href="/article/cbf3079f.html">windows虚拟内存自动管理好还是手动设置好？ 如果是手动设置多少合适？</a></li><li class="post-list-item"><a class="post-list-link" href="/article/763d6087.html">vue3中ts提示扩张参数必须具有元组类型或传递给rest参数</a></li><li class="post-list-item"><a class="post-list-link" href="/article/2f775138.html">vue3 组件 has no default export</a></li></ul></div><div class="widget widget-recent-comments"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><div class="waline-recent" id="waline-recent"></div></div><script type="module">//- import { RecentComments } from  '//cdn.jsdelivr.net/npm/@waline/client/dist/waline.mjs';
import { RecentComments } from  'https://xuehuayu.cn/js/waline.mjs';

const origin = window.location.origin
const serverURL = origin.includes('cainiaoblog') ? 'https://guest.cainiaoblog.cn' : 'https://guest.xuehuayu.cn'

RecentComments({
  el: '#waline-recent',
  serverURL,
  count: 5,
}).then(({ comments }) => {
  const commentList = comments.map(
    (comment) => {
      const cmts = ((comment||{}).comment || '').replace(/<\/?.*?>/g, '').replace(/\n/g, ' ')
      const time = ((comment||{}).insertedAt || '').substring(0, 10)
      const link = (comment||{}).link
      const info = link ? `<a class="flex-block align-center" href="${link}"><img class="comment-avatar" width="30" src="${comment.avatar}" alt="${comment.nick}"/><span class="comment-nick">${comment.nick}</span></a>` : `<img class="comment-avatar" width="30" src="${comment.avatar}" alt="${comment.nick}"/><span class="comment-nick">${comment.nick}</span>`
      const url = (comment||{}).url + '#' + (comment||{}).objectId
      return `<li class="comment-list-item"><div class="comment-top flex-block justify-between align-center"><div class="comment-info flex-block align-center">${info}</div><span>${time}</span></div><div class="comment-content"><a class="post-list-link line-3" href="${url}">${cmts}</a></div></li>`
    }
  );
  document.getElementById('waline-recent').innerHTML = `<url class="comment-list">${commentList.join('')}</ul>`
});</script><div class="widget widget-categories"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ADBlock/">ADBlock</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/">Blog</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/FrontEnd/">FrontEnd</a><span class="category-list-count">277</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Histiry/">Histiry</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/KKPlayer/">KKPlayer</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Movies/">Movies</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E7%A8%8E/">个税</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%84%BF%E7%AB%A5/">儿童</a><span class="category-list-count">8</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%84%BF%E7%AB%A5/%E5%81%A5%E5%BA%B7/">健康</a><span class="category-list-count">8</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%84%BF%E7%AB%A5/%E5%81%A5%E5%BA%B7/children/">children</a><span class="category-list-count">8</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%84%BF%E7%AB%A5/%E5%81%A5%E5%BA%B7/children/health/">health</a><span class="category-list-count">8</span></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7/">公众号</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">292</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/FrontEnd/">FrontEnd</a><span class="category-list-count">16</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8E%86%E5%8F%B2/">历史</a><span class="category-list-count">6</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8E%86%E5%8F%B2/Histiry/">Histiry</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%BF%E5%91%8A%E8%BF%87%E6%BB%A4/">广告过滤</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BD%B1%E8%A7%86/">影视</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B8%B8%E6%88%8F/">游戏</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A5%9E%E8%AF%9D/">神话</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%B3%BB%E7%BB%9F/">系统</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%B3%BB%E7%BB%9F/System/">System</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%9B%98/">网盘</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%8A%82%E7%82%B9/">节点</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%A3%85%E4%BF%AE/">装修</a><span class="category-list-count">1</span></li></ul></div><div class="widget widget-links"><div class="widget-title"><i class="fa fa-external-link"> 友链</i></div><ul><li><a href="https://h5.lot-ml.com/ProductEn/Index/1be1066f15176ef6/?utm_source=xuehuayu.cn&amp;utm_term=KKPlayer" title="四大运营商大流量手机卡终身套餐" target="_blank">四大运营商大流量手机卡终身套餐</a></li><li><a href="https://m3u8.xuehuayu.cn?utm_source=xuehuayu.cn&amp;utm_term=KKPlayer" title="M3U8加速播放器" target="_blank">M3U8加速播放器</a></li><li><a href="https://chrome.xuehuayu.cn?utm_source=xuehuayu.cn&amp;utm_term=KKPlayer" title="Chrome命令行参数生成器" target="_blank">Chrome命令行参数生成器</a></li><li><a href="https://laonongmin.online?utm_source=xuehuayu.cn&amp;utm_term=KKPlayer" title="KK Player" target="_blank">KK Player</a></li></ul></div><div class="widget widget-ip"><div class="widget-title"></div><img alt="info" width="100%" src="https://tool.lu/netcard/" onclick="window.open(&quot;https://laonongmin.online&quot;)"/></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"><div class="flex-block justify-center align-center flex-wrap"><a class="gxba-link" id="gxba" rel="nofollow" target="_blank" href="http://beian.miit.gov.cn/">京ICP备20007647号-2</a><a class="gaba-link" id="gaba-link" rel="nofollow" target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802031264"><img class="nofancybox" src="/img/gaba.png" alt=""/><span id="gaba">京公网安备 11010802031264号</span><span style="padding-right: 10px;"></span></a><span>Copyright © 2025 </span><a href="/." rel="nofollow">前端壹菜鸟. </a><script>(function(){
  var cnb =window.location.origin.includes('cainiaoblog')
  if (cnb) {
    var gxba =document.getElementById('gxba')
    var gaba =document.getElementById('gaba')
    var gabaLink =document.getElementById('gaba-link')
    gxba.innerText ='京ICP备20007647号-1'
    gaba.innerText ='京公网安备 11010802031254号'
    gabaLink.setAttribute('href','http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802031254')
  }
})()</script></div></div></div></div><a class="show" id="rocket" title="返回顶部" href="#top"></a><div class="darkmode-toggle" title="开灯/关灯">🌓</div><script type="text/javascript" src="/js/totop.js?v=9" async></script><script type="text/javascript" src="/js/dark.js?v=9" async></script><script type="text/javascript" src="/js/codeblock-resizer.js"></script><script type="text/javascript" src="/js/smartresize.js"></script></div></body><div class="footer-links"><i class="fa fa-external-link"> 友链</i><span>：</span><span class="link"><span class="gap gap-0">|</span><a href="https://h5.lot-ml.com/ProductEn/Index/1be1066f15176ef6/?utm_source=xuehuayu.cn&amp;utm_term=KKPlayer" title="四大运营商大流量手机卡终身套餐" target="_blank">四大运营商大流量手机卡终身套餐</a></span><span class="link"><span class="gap gap-1">|</span><a href="https://m3u8.xuehuayu.cn?utm_source=xuehuayu.cn&amp;utm_term=KKPlayer" title="M3U8加速播放器" target="_blank">M3U8加速播放器</a></span><span class="link"><span class="gap gap-2">|</span><a href="https://chrome.xuehuayu.cn?utm_source=xuehuayu.cn&amp;utm_term=KKPlayer" title="Chrome命令行参数生成器" target="_blank">Chrome命令行参数生成器</a></span><span class="link"><span class="gap gap-3">|</span><a href="https://laonongmin.online?utm_source=xuehuayu.cn&amp;utm_term=KKPlayer" title="KK Player" target="_blank">KK Player</a></span></div></html>