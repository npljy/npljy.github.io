<!DOCTYPE html><html lang="zh-CN" data-dark><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="format-detection" content="telephone=no"><meta name="description" content="前端搬砖大老，写写搬砖那些事儿"><meta name="msvalidate.01" content="0FE4D8B3381D3D87088996B886E1E2BD"><meta name="google-adsense-account" content="ca-pub-8385136408348258"><meta name="keywords" content="前端壹菜鸟, HTML,CSS,JavaScript,ES6+,Sass,Less,Stylus,PostCSS,BEM,TailwindCSS,Bootstrap,React,Vue.js,Angular,Svelte,TypeScript,Vite,Webpack,npm,Yarn,pnpm,Redux,Zustand,Pinia,ReactRouter,VueRouter,ESLint,Prettier,Git,Node.js,ReactNative,Flutter,Electron,Next.js,Nuxt.js,Micro-frontends,WebAssembly,PWA,Three.js,前端,技术博客,转载,FrontEnd"><title>ES6，ES7，ES8，ES9，ES10新特性一览 | 前端壹菜鸟</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="icon" mask="" sizes="any" href="/img/blog.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/img/blog.ico"><link rel="apple-touch-icon" href="/img/blog.png"><link rel="apple-touch-icon-precomposed" href="/img/blog.png"><script type="text/javascript" src="/js/jquery.min.js"></script><script type="text/javascript" src="/js/isPhone.js"></script><script type="text/javascript" src="/js/fixedPage.jm.js"></script><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8385136408348258"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  document.head.append(bp)
})();
</script><script async src="https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-ETCMPGS7S6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);};gtag('js',new Date());gtag('config','G-ETCMPGS7S6');
</script><script type="application/ld+json">{
  "@context": "https://schema.org",
  "keywords": "HTML,CSS,JavaScript,ES6+,Sass,Less,Stylus,PostCSS,BEM,TailwindCSS,Bootstrap,React,Vue.js,Angular,Svelte,TypeScript,Vite,Webpack,npm,Yarn,pnpm,Redux,Zustand,Pinia,ReactRouter,VueRouter,ESLint,Prettier,Git,Node.js,ReactNative,Flutter,Electron,Next.js,Nuxt.js,Micro-frontends,WebAssembly,PWA,Three.js,前端,技术博客",
  "description": "前端搬砖大老，写写搬砖那些事儿",
  "operatingSystem": "Any",
  "permissions": "browser",
  "author": {
    "@type": "Person",
    "name": "前端壹菜鸟"
  },
  "@graph": [{
    "@type": "WebSite",
    "name": "前端壹菜鸟",
    "url": "https://xuehuayu.cn",
  }, {
    "@type": "WebSite",
    "name": "前端壹菜鸟",
    "url": "https://cainiaoblog.cn",
  }, ]
}</script><meta name="generator" content="Hexo 8.1.0"></head><body><div class="body_container"><div id="webtraf_17015" style="width:100%;display:flex;justify-content: center;"><script src="https://webtrafic.ru/ads.php?uid=17015" async></script></div><div id="header"><div class="site-name"><a id="logo" href="/.">前端壹菜鸟</a><p class="description">关注前端知识，收集精彩博文，做技术的搬运工</p></div><div id="nav-menu"><a class="current" href="/." target="_self"><i class="fa fa-home"> 首页</i></a><a href="/archives/" target="_self"><i class="fa fa-archive"> 归档</i></a><a href="/guestbook/" target="_self"><i class="fa fa-comments"> 留言</i></a><a href="https://afdian.com/a/big_old/thank" target="_self"><i class="fa fa-group"> 感谢</i></a><a href="https://love.xuehuayu.cn/" target="_self"><i class="fa fa-heart"> LOVE</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title c-post">ES6，ES7，ES8，ES9，ES10新特性一览</h1><div class="post-meta"><span class="date">2019-12-02</span><span> | </span><span class="reproduce">转载 </span><span> | </span><span class="category"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端 </a><a href="/categories/FrontEnd/">FrontEnd </a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 8.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 35</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" href="/article/dc8dc705.html#waline-comment"><span class="waline-comment-count" data-path="/article/dc8dc705.html">0</span><span> 条评论</span></a><div class="post-content"><p><code>原文地址：https://mp.weixin.qq.com/s/9z9gmea7ara4ZSWzo7QruQ</code></p>
<blockquote>
</blockquote>
<p>ES全称ECMAScript，ECMAScript是ECMA制定的标准化脚本语言。目前JavaScript使用的ECMAScript版本为<a target="_blank" rel="noopener" href="https://ecma-international.org/publications/standards/Ecma-417.htm">ECMA-417</a>。关于ECMA的最新资讯可以浏览</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.ecma-international.org/news/index.html">ECMA news</a>查看。</p>
</blockquote>
<span id="more"></span>

<p>ECMA规范最终由<a target="_blank" rel="noopener" href="https://github.com/tc39">TC39</a>敲定。TC39由包括浏览器厂商在内的各方组成，他们开会推动JavaScript提案沿着一条严格的发展道路前进。<br>从提案到入选ECMA规范主要有以下几个阶段：</p>
<ul>
<li>Stage 0: strawman——最初想法的提交。</li>
<li>Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。</li>
<li>Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。</li>
<li>Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈</li>
<li>Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间。</li>
</ul>
<h2 id="ES6新特性（2015）"><a href="#ES6新特性（2015）" class="headerlink" title="ES6新特性（2015）"></a>ES6新特性（2015）</h2><p>ES6的特性比较多，在 ES5 发布近 6 年（2009-11 至 2015-6）之后才将其标准化。两个发布版本之间时间跨度很大，所以ES6中的特性比较多。<br>在这里列举几个常用的：</p>
<ul>
<li>类</li>
<li>模块化</li>
<li>箭头函数</li>
<li>函数参数默认值</li>
<li>模板字符串</li>
<li>解构赋值</li>
<li>延展操作符</li>
<li>对象属性简写</li>
<li>Promise</li>
<li>Let与Const</li>
</ul>
<h3 id="1-类（class）"><a href="#1-类（class）" class="headerlink" title="1.类（class）"></a>1.类（class）</h3><p>对熟悉Java，object-c，c#等纯面向对象语言的开发者来说，都会对class有一种特殊的情怀。ES6<br>引入了class（类），让JavaScript的面向对象编程变得更加简单和易于理解。</p>
<pre><code>classAnimal{
    // 构造函数，实例化的时候将会被调用，如果不指定，那么会有一个不带参数的默认构造函数.constructor(name,color) {
      this.name = name;
      this.color = color;
    }
    // toString 是原型对象上的属性
    toString() {
      console.log(&#39;name:&#39; + this.name + &#39;,color:&#39; + this.color);

    }
  }

  var animal = new Animal(&#39;dog&#39;,&#39;white&#39;);//实例化Animal
  animal.toString();

  console.log(animal.hasOwnProperty(&#39;name&#39;)); //trueconsole.log(animal.hasOwnProperty(&#39;toString&#39;)); // falseconsole.log(animal.__proto__.hasOwnProperty(&#39;toString&#39;)); // trueclassCatextendsAnimal{
  constructor(action) {
    // 子类必须要在constructor中指定super 函数，否则在新建实例的时候会报错.// 如果没有置顶consructor,默认带super函数的constructor将会被添加、super(&#39;cat&#39;,&#39;white&#39;);
    this.action = action;
  }
  toString() {
    console.log(super.toString());
  }
  }

  var cat = new Cat(&#39;catch&#39;)
  cat.toString();

  // 实例cat 是 Cat 和 Animal 的实例，和Es5完全一致。console.log(cat instanceof Cat); // trueconsole.log(cat instanceof Animal); // true复制代码
</code></pre>
<h3 id="2-模块化-Module"><a href="#2-模块化-Module" class="headerlink" title="2.模块化(Module)"></a>2.模块化(Module)</h3><p>ES5不支持原生的模块化，在ES6中模块作为重要的组成部分被添加进来。模块的功能主要由 export 和 import<br>组成。每一个模块都有自己单独的作用域，模块之间的相互调用关系是通过 export<br>来规定模块对外暴露的接口，通过import来引用其它模块提供的接口。同时还为模块创造了命名空间，防止函数的命名冲突。</p>
<h4 id="导出-export"><a href="#导出-export" class="headerlink" title="导出(export)"></a>导出(export)</h4><p>ES6允许在一个模块中使用export来导出多个变量或函数。</p>
<p><strong>导出变量</strong></p>
<pre><code>//test.jsexportvar name = &#39;Rainbow&#39;复制代码
</code></pre>
<blockquote>
<p>心得：ES6不仅支持变量的导出，也支持常量的导出。 <code>export const sqrt = Math.sqrt;//导出常量</code></p>
</blockquote>
<p>ES6将一个文件视为一个模块，上面的模块通过 export 向外输出了一个变量。一个模块也可以同时往外面输出多个变量。</p>
<pre><code>//test.jsvar name = &#39;Rainbow&#39;;
  var age = &#39;24&#39;;
  export {name, age};

复制代码
</code></pre>
<p><strong>导出函数</strong></p>
<pre><code>// myModule.jsexportfunctionmyModule(someArg) {
  return someArg;
}

复制代码
</code></pre>
<h4 id="导入-import"><a href="#导入-import" class="headerlink" title="导入(import)"></a>导入(import)</h4><p>定义好模块的输出以后就可以在另外一个模块通过import引用。</p>
<pre><code>import {myModule} from&#39;myModule&#39;;// main.jsimport {name,age} from&#39;test&#39;;// test.js复制代码
</code></pre>
<blockquote>
<p>心得:一条import 语句可以同时导入默认函数和其它变量。&#96;import defaultMethod, { otherMethod } from</p>
</blockquote>
<p>‘xxx.js’;&#96;</p>
<h3 id="3-箭头（Arrow）函数"><a href="#3-箭头（Arrow）函数" class="headerlink" title="3.箭头（Arrow）函数"></a>3.箭头（Arrow）函数</h3><p>这是ES6中最令人激动的特性之一。<code>=&gt;</code>不只是关键字function的简写，它还带来了其它好处。箭头函数与包围它的代码共享同一个<code>this</code>,能帮你很好的解决this的指向问题。有经验的JavaScript开发者都熟悉诸如<code>var self = this;</code>或<code>var that = this</code>这种引用外围this的模式。但借助<code>=&gt;</code>，就不需要这种模式了。</p>
<h4 id="箭头函数的结构"><a href="#箭头函数的结构" class="headerlink" title="箭头函数的结构"></a>箭头函数的结构</h4><p>箭头函数的箭头&#x3D;&gt;之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过return来返回值，否则返回的是undefined）。</p>
<pre><code>// 箭头函数的例子
()=&gt;1
v=&gt;v+1
(a,b)=&gt;a+b
()=&gt;{
    alert(&quot;foo&quot;);
}
e=&gt;{
    if (e == 0){
        return0;
    }
    return1000/e;
}

复制代码
</code></pre>
<blockquote>
</blockquote>
<p>心得：不论是箭头函数还是bind，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用。</p>
<h4 id="卸载监听器时的陷阱"><a href="#卸载监听器时的陷阱" class="headerlink" title="卸载监听器时的陷阱"></a>卸载监听器时的陷阱</h4><blockquote>
<p><strong>错误的做法</strong></p>
</blockquote>
<pre><code>classPauseMenuextendsReact.Component{
    componentWillMount(){
        AppStateIOS.addEventListener(&#39;change&#39;, this.onAppPaused.bind(this));
    }
    componentWillUnmount(){
        AppStateIOS.removeEventListener(&#39;change&#39;, this.onAppPaused.bind(this));
    }
    onAppPaused(event){
    }
}

复制代码
</code></pre>
<blockquote>
<p><strong>正确的做法</strong></p>
</blockquote>
<pre><code>classPauseMenuextendsReact.Component{
    constructor(props){
        super(props);
        this._onAppPaused = this.onAppPaused.bind(this);
    }
    componentWillMount(){
        AppStateIOS.addEventListener(&#39;change&#39;, this._onAppPaused);
    }
    componentWillUnmount(){
        AppStateIOS.removeEventListener(&#39;change&#39;, this._onAppPaused);
    }
    onAppPaused(event){
    }
}

复制代码
</code></pre>
<p>除上述的做法外，我们还可以这样做：</p>
<pre><code>classPauseMenuextendsReact.Component{
    componentWillMount(){
        AppStateIOS.addEventListener(&#39;change&#39;, this.onAppPaused);
    }
    componentWillUnmount(){
        AppStateIOS.removeEventListener(&#39;change&#39;, this.onAppPaused);
    }
    onAppPaused = (event) =&gt; {
        //把函数直接作为一个arrow function的属性来定义，初始化的时候就绑定好了this指针
    }
}

复制代码
</code></pre>
<blockquote>
</blockquote>
<p>需要注意的是：不论是bind还是箭头函数，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用。</p>
<h3 id="4-函数参数默认值"><a href="#4-函数参数默认值" class="headerlink" title="4.函数参数默认值"></a>4.<a href="https://link.juejin.im/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/default_parameters">函数参数默认值</a></h3><p>ES6支持在定义函数的时候为其设置默认值：</p>
<pre><code>functionfoo(height = 50, color = &#39;red&#39;)
{
    // ...
}

复制代码
</code></pre>
<blockquote>
<p>不使用默认值：</p>
</blockquote>
<pre><code>functionfoo(height, color)
{
    var height = height || 50;
    var color = color || &#39;red&#39;;
    //...
}

复制代码
</code></pre>
<p>这样写一般没问题，但当<code>参数的布尔值为false</code>时，就会有问题了。比如，我们这样调用foo函数：</p>
<pre><code>foo(0, &quot;&quot;)

复制代码
</code></pre>
<p>因为<code>0的布尔值为false</code>，这样height的取值将是50。同理color的取值为‘red’。</p>
<p>所以说，<code>函数参数默认值</code>不仅能是代码变得更加简洁而且能规避一些问题。</p>
<h3 id="5-模板字符串"><a href="#5-模板字符串" class="headerlink" title="5.模板字符串"></a>5.模板字符串</h3><p>ES6支持<code>模板字符串</code>，使得字符串的拼接更加的简洁、直观。</p>
<blockquote>
<p>不使用模板字符串：</p>
</blockquote>
<pre><code>var name = &#39;Your name is &#39; + first + &#39; &#39; + last + &#39;.&#39;复制代码
</code></pre>
<blockquote>
<p>使用模板字符串：</p>
</blockquote>
<pre><code>var name = `Your name is ${first}${last}.`复制代码
</code></pre>
<p>在ES6中通过<code>${}</code>就可以完成字符串的拼接，只需要将变量放在大括号之中。</p>
<h3 id="6-解构赋值"><a href="#6-解构赋值" class="headerlink" title="6.解构赋值"></a>6.<a href="https://link.juejin.im/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构赋值</a></h3><p>解构赋值语法是JavaScript的一种表达式，可以方便的从数组或者对象中快速提取值赋给定义的变量。</p>
<h4 id="获取数组中的值"><a href="#获取数组中的值" class="headerlink" title="获取数组中的值"></a>获取数组中的值</h4><p>从数组中获取值并赋值到变量中，变量的顺序与数组中对象顺序对应。</p>
<pre><code>var foo = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;];

var [one, two, three] = foo;
console.log(one); // &quot;one&quot;console.log(two); // &quot;two&quot;console.log(three); // &quot;three&quot;//如果你要忽略某些值，你可以按照下面的写法获取你想要的值var [first, , , last] = foo;
console.log(first); // &quot;one&quot;console.log(last); // &quot;four&quot;//你也可以这样写var a, b; //先声明变量

[a, b] = [1, 2];
console.log(a); // 1console.log(b); // 2复制代码
</code></pre>
<p>如果没有从数组中的获取到值，你可以为变量设置一个默认值。</p>
<pre><code>var a, b;

[a=5, b=7] = [1];
console.log(a); // 1console.log(b); // 7复制代码
</code></pre>
<p>通过解构赋值可以方便的交换两个变量的值。</p>
<pre><code>var a = 1;
var b = 3;

[a, b] = [b, a];
console.log(a); // 3console.log(b); // 1复制代码
</code></pre>
<h4 id="获取对象中的值"><a href="#获取对象中的值" class="headerlink" title="获取对象中的值"></a>获取对象中的值</h4><pre><code>const student = {
  name:&#39;Ming&#39;,
  age:&#39;18&#39;,
  city:&#39;Shanghai&#39;
};

const {name,age,city} = student;
console.log(name); // &quot;Ming&quot;console.log(age); // &quot;18&quot;console.log(city); // &quot;Shanghai&quot;复制代码
</code></pre>
<h3 id="7-延展操作符-Spread-operator"><a href="#7-延展操作符-Spread-operator" class="headerlink" title="7.延展操作符(Spread operator)"></a>7.延展操作符(Spread operator)</h3><p><code>延展操作符...</code>可以在函数调用&#x2F;数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造对象时, 将对象表达式按key-value的方式展开。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><blockquote>
<p>函数调用：</p>
</blockquote>
<pre><code>myFunction(...iterableObj);

复制代码
</code></pre>
<blockquote>
<p>数组构造或字符串：</p>
</blockquote>
<pre><code>[...iterableObj, &#39;4&#39;, ...&#39;hello&#39;, 6];

复制代码
</code></pre>
<blockquote>
<p>构造对象时,进行克隆或者属性拷贝（ECMAScript 2018规范新增特性）：</p>
</blockquote>
<pre><code>let objClone = { ...obj };

复制代码
</code></pre>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><blockquote>
<p>在函数调用时使用延展操作符</p>
</blockquote>
<pre><code>functionsum(x, y, z) {
  return x + y + z;
}
const numbers = [1, 2, 3];

//不使用延展操作符console.log(sum.apply(null, numbers));

//使用延展操作符console.log(sum(...numbers));// 6复制代码
</code></pre>
<blockquote>
<p>构造数组</p>
</blockquote>
<p>没有展开语法的时候，只能组合使用 push，splice，concat 等方法，来将已有数组元素变成新数组的一部分。有了展开语法,<br>构造新数组会变得更简单、更优雅：</p>
<pre><code>const stuendts = [&#39;Jine&#39;,&#39;Tom&#39;];
const persons = [&#39;Tony&#39;,... stuendts,&#39;Aaron&#39;,&#39;Anna&#39;];
conslog.log(persions)// [&quot;Tony&quot;, &quot;Jine&quot;, &quot;Tom&quot;, &quot;Aaron&quot;, &quot;Anna&quot;]复制代码
</code></pre>
<p>和参数列表的展开类似, <code>...</code> 在构造字数组时, 可以在任意位置多次使用。</p>
<blockquote>
<p>数组拷贝</p>
</blockquote>
<pre><code>var arr = [1, 2, 3];
var arr2 = [...arr]; // 等同于 arr.slice()
arr2.push(4);
console.log(arr2)//[1, 2, 3, 4]复制代码
</code></pre>
<p>展开语法和 Object.assign() 行为一致, 执行的都是浅拷贝(只遍历一层)。</p>
<blockquote>
<p>连接多个数组</p>
</blockquote>
<pre><code>var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
var arr3 = [...arr1, ...arr2];// 将 arr2 中所有元素附加到 arr1 后面并返回//等同于var arr4 = arr1.concat(arr2);

复制代码
</code></pre>
<h4 id="在ECMAScript-2018中延展操作符增加了对对象的支持"><a href="#在ECMAScript-2018中延展操作符增加了对对象的支持" class="headerlink" title="在ECMAScript 2018中延展操作符增加了对对象的支持"></a>在ECMAScript 2018中延展操作符增加了对对象的支持</h4><pre><code>var obj1 = { foo: &#39;bar&#39;, x: 42 };
var obj2 = { foo: &#39;baz&#39;, y: 13 };

var clonedObj = { ...obj1 };
// 克隆后的对象: { foo: &quot;bar&quot;, x: 42 }var mergedObj = { ...obj1, ...obj2 };
// 合并后的对象: { foo: &quot;baz&quot;, x: 42, y: 13 }复制代码
</code></pre>
<h4 id="在React中的应用"><a href="#在React中的应用" class="headerlink" title="在React中的应用"></a>在React中的应用</h4><p>通常我们在封装一个组件时，会对外公开一些 props 用于实现功能。大部分情况下在外部使用都应显示的传递 props<br>。但是当传递大量的props时，会非常繁琐，这时我们可以使用 <code>...(延展操作符,用于取出参数对象的所有可遍历属性)</code> 来进行传递。</p>
<h4 id="一般情况下我们应该这样写"><a href="#一般情况下我们应该这样写" class="headerlink" title="一般情况下我们应该这样写"></a>一般情况下我们应该这样写</h4><pre><code>&lt;CustomComponent name =&#39;Jine&#39; age ={21} /&gt;

复制代码
</code></pre>
<blockquote>
<p>使用 … ，等同于上面的写法</p>
</blockquote>
<pre><code>const params = {
  name: &#39;Jine&#39;,
  age: 21
}
&lt;CustomComponent {...params} /&gt;
复制代码
</code></pre>
<blockquote>
<p>配合解构赋值避免传入一些不需要的参数</p>
</blockquote>
<pre><code>var params = {
  name: &#39;123&#39;,
  title: &#39;456&#39;,
  type: &#39;aaa&#39;
}

var { type, ...other } = params;

&lt;CustomComponent type=&#39;normal&#39; number={2} {...other} /&gt;
//等同于
&lt;CustomComponent type=&#39;normal&#39; number={2} name=&#39;123&#39; title=&#39;456&#39; /&gt;

复制代码
</code></pre>
<h3 id="8-对象属性简写"><a href="#8-对象属性简写" class="headerlink" title="8.对象属性简写"></a>8.对象属性简写</h3><p>在ES6中允许我们在设置一个对象的属性的时候不指定属性名。</p>
<blockquote>
<p>不使用ES6</p>
</blockquote>
<pre><code>const name=&#39;Ming&#39;,age=&#39;18&#39;,city=&#39;Shanghai&#39;;

const student = {
    name:name,
    age:age,
    city:city
};
console.log(student);//{name: &quot;Ming&quot;, age: &quot;18&quot;, city: &quot;Shanghai&quot;}复制代码
</code></pre>
<p>对象中必须包含属性和值，显得非常冗余。</p>
<blockquote>
<p>使用ES6</p>
</blockquote>
<pre><code>const name=&#39;Ming&#39;,age=&#39;18&#39;,city=&#39;Shanghai&#39;;

const student = {
    name,
    age,
    city
};
console.log(student);//{name: &quot;Ming&quot;, age: &quot;18&quot;, city: &quot;Shanghai&quot;}复制代码
</code></pre>
<p>对象中直接写变量，非常简洁。</p>
<h3 id="9-Promise"><a href="#9-Promise" class="headerlink" title="9.Promise"></a>9.<a href="https://link.juejin.im/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">Promise</a></h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案callback更加的优雅。它最早由社区提出和实现的，ES6<br>将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<blockquote>
<p>不使用ES6</p>
</blockquote>
<p>嵌套两个setTimeout回调函数：</p>
<pre><code>setTimeout(function()
{
    console.log(&#39;Hello&#39;); // 1秒后输出&quot;Hello&quot;
    setTimeout(function()
    {
        console.log(&#39;Hi&#39;); // 2秒后输出&quot;Hi&quot;
    }, 1000);
}, 1000);

复制代码
</code></pre>
<blockquote>
<p>使用ES6</p>
</blockquote>
<pre><code>var waitSecond = newPromise(function(resolve, reject)
{
    setTimeout(resolve, 1000);
});

waitSecond
    .then(function()
    {
      console.log(&quot;Hello&quot;); // 1秒后输出&quot;Hello&quot;return waitSecond;
    })
    .then(function()
    {
        console.log(&quot;Hi&quot;); // 2秒后输出&quot;Hi&quot;
    });

复制代码
</code></pre>
<p>上面的的代码使用两个then来进行异步编程串行化，避免了回调地狱：</p>
<h3 id="10-支持let与const"><a href="#10-支持let与const" class="headerlink" title="10.支持let与const"></a>10.支持let与const</h3><p>在之前JS是没有块级作用域的，const与let填补了这方便的空白，const与let都是块级作用域。</p>
<blockquote>
<p>使用var定义的变量为函数级作用域：</p>
</blockquote>
<pre><code>{
  var a = 10;
}

console.log(a); // 输出10复制代码
</code></pre>
<blockquote>
<p>使用let与const定义的变量为块级作用域：</p>
</blockquote>
<pre><code>{
  let a = 10;
}

console.log(a); //-1 or Error“ReferenceError: a is not defined”复制代码
</code></pre>
<h2 id="ES7新特性（2016）"><a href="#ES7新特性（2016）" class="headerlink" title="ES7新特性（2016）"></a>ES7新特性（2016）</h2><p>ES2016添加了两个小的特性来说明标准化过程：</p>
<ul>
<li>数组includes()方法，用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回true，否则返回false。</li>
<li>a ** b指数运算符，它与 Math.pow(a, b)相同。</li>
</ul>
<h3 id="1-Array-prototype-includes"><a href="#1-Array-prototype-includes" class="headerlink" title="1.Array.prototype.includes()"></a>1.Array.prototype.includes()</h3><p><code>includes()</code> 函数用来判断一个数组是否包含一个指定的值，如果包含则返回 <code>true</code>，否则返回<code>false</code>。</p>
<p><code>includes</code> 函数与 <code>indexOf</code> 函数很相似，下面两个表达式是等价的：</p>
<pre><code>arr.includes(x)
arr.indexOf(x) &gt;= 0复制代码
</code></pre>
<p>接下来我们来判断数字中是否包含某个元素：</p>
<blockquote>
<p>在ES7之前的做法</p>
</blockquote>
<p>使用<code>indexOf()</code>验证数组中是否存在某个元素，这时需要根据返回值是否为-1来判断：</p>
<pre><code>let arr = [&#39;react&#39;, &#39;angular&#39;, &#39;vue&#39;];

if (arr.indexOf(&#39;react&#39;) !== -1)
{
    console.log(&#39;react存在&#39;);
}

复制代码
</code></pre>
<blockquote>
<p>使用ES7的includes()</p>
</blockquote>
<p>使用includes()验证数组中是否存在某个元素，这样更加直观简单：</p>
<pre><code>let arr = [&#39;react&#39;, &#39;angular&#39;, &#39;vue&#39;];

if (arr.includes(&#39;react&#39;))
{
    console.log(&#39;react存在&#39;);
}
复制代码
</code></pre>
<h3 id="2-指数操作符"><a href="#2-指数操作符" class="headerlink" title="2.指数操作符"></a>2.指数操作符</h3><p>在ES7中引入了指数运算符<code>**</code>，<code>**</code>具有与<code>Math.pow(..)</code>等效的计算结果。</p>
<blockquote>
<p>不使用指数操作符</p>
</blockquote>
<p>使用自定义的递归函数calculateExponent或者Math.pow()进行指数运算：</p>
<pre><code>functioncalculateExponent(base, exponent)
{
    if (exponent === 1)
    {
        return base;
    }
    else
    {
        return base * calculateExponent(base, exponent - 1);
    }
}

console.log(calculateExponent(2, 10)); // 输出1024console.log(Math.pow(2, 10)); // 输出1024复制代码
</code></pre>
<blockquote>
<p>使用指数操作符</p>
</blockquote>
<p>使用指数运算符**，就像+、-等操作符一样：</p>
<pre><code>console.log(2**10);// 输出1024复制代码
</code></pre>
<h2 id="ES8新特性（2017）"><a href="#ES8新特性（2017）" class="headerlink" title="ES8新特性（2017）"></a>ES8新特性（2017）</h2><ul>
<li>async&#x2F;await</li>
<li><code>Object.values()</code></li>
<li><code>Object.entries()</code></li>
<li>String padding: <code>padStart()</code>和<code>padEnd()</code>，填充字符串达到当前长度</li>
<li>函数参数列表结尾允许逗号</li>
<li><code>Object.getOwnPropertyDescriptors()</code></li>
<li><code>ShareArrayBuffer</code>和<code>Atomics</code>对象，用于从共享内存位置读取和写入</li>
</ul>
<h3 id="1-async-await"><a href="#1-async-await" class="headerlink" title="1.async&#x2F;await"></a>1.async&#x2F;await</h3><p>ES2018引入异步迭代器（asynchronous<br>iterators），这就像常规迭代器，除了<code>next()</code>方法返回一个Promise。因此<code>await</code>可以和<code>for...of</code>循环一起使用，以串行的方式运行异步操作。例如：</p>
<pre><code>asyncfunctionprocess(array) {
  forawait (let i of array) {
    doSomething(i);
  }
}
复制代码
</code></pre>
<h3 id="2-Object-values"><a href="#2-Object-values" class="headerlink" title="2.Object.values()"></a>2.Object.values()</h3><p><code>Object.values()</code>是一个与<code>Object.keys()</code>类似的新函数，但返回的是Object自身属性的所有值，不包括继承的值。</p>
<p>假设我们要遍历如下对象<code>obj</code>的所有值：</p>
<pre><code>const obj = {a: 1, b: 2, c: 3};
复制代码
</code></pre>
<blockquote>
<p>不使用Object.values() :ES7</p>
</blockquote>
<pre><code>const vals=Object.keys(obj).map(key=&gt;obj[key]);
console.log(vals);//[1, 2, 3]复制代码
</code></pre>
<blockquote>
<p>使用Object.values() :ES8</p>
</blockquote>
<pre><code>const values=Object.values(obj1);
console.log(values);//[1, 2, 3]复制代码
</code></pre>
<p>从上述代码中可以看出<code>Object.values()</code>为我们省去了遍历key，并根据这些key获取value的步骤。</p>
<h3 id="3-Object-entries"><a href="#3-Object-entries" class="headerlink" title="3.Object.entries()"></a>3.Object.entries()</h3><p><code>Object.entries()</code>函数返回一个给定对象自身可枚举属性的键值对的数组。</p>
<p>接下来我们来遍历上文中的<code>obj</code>对象的所有属性的key和value：</p>
<blockquote>
<p>不使用Object.entries() :ES7</p>
</blockquote>
<pre><code>Object.keys(obj).forEach(key=&gt;{
  console.log(&#39;key:&#39;+key+&#39; value:&#39;+obj[key]);
})
//key:a value:1//key:b value:2//key:c value:3复制代码
</code></pre>
<blockquote>
<p>使用Object.entries() :ES8</p>
</blockquote>
<pre><code>for(let [key,value] ofObject.entries(obj1)){
  console.log(`key: ${key} value:${value}`)
}
//key:a value:1//key:b value:2//key:c value:3复制代码
</code></pre>
<h3 id="4-String-padding"><a href="#4-String-padding" class="headerlink" title="4.String padding"></a>4.String padding</h3><p>在ES8中String新增了两个实例函数<code>String.prototype.padStart</code>和<code>String.prototype.padEnd</code>，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。</p>
<blockquote>
<p>String.padStart(targetLength,[padString])</p>
</blockquote>
<ul>
<li>targetLength:当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</li>
<li>padString:(可选)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为 “</li>
</ul>
<p>“。</p>
<pre><code>console.log(&#39;0.0&#39;.padStart(4,&#39;10&#39;)) //10.0console.log(&#39;0.0&#39;.padStart(20))// 0.00    复制代码
</code></pre>
<blockquote>
<p>String.padEnd(targetLength,padString])</p>
</blockquote>
<ul>
<li>targetLength:当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</li>
<li>padString:(可选) 填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为 “</li>
</ul>
<p>“；</p>
<pre><code>console.log(&#39;0.0&#39;.padEnd(4,&#39;0&#39;)) //0.00    console.log(&#39;0.0&#39;.padEnd(10,&#39;0&#39;))//0.00000000复制代码
</code></pre>
<h3 id="5-函数参数列表结尾允许逗号"><a href="#5-函数参数列表结尾允许逗号" class="headerlink" title="5.函数参数列表结尾允许逗号"></a>5.函数参数列表结尾允许逗号</h3><p>主要作用是方便使用git进行多人协作开发时修改同一个函数减少不必要的行变更。</p>
<h3 id="6-Object-getOwnPropertyDescriptors"><a href="#6-Object-getOwnPropertyDescriptors" class="headerlink" title="6.Object.getOwnPropertyDescriptors()"></a>6.Object.getOwnPropertyDescriptors()</h3><p><code>Object.getOwnPropertyDescriptors()</code>函数用来获取一个对象的所有自身属性的描述符,如果没有任何自身属性，则返回空对象。</p>
<blockquote>
<p>函数原型：</p>
</blockquote>
<pre><code>Object.getOwnPropertyDescriptors(obj)
复制代码
</code></pre>
<p>返回<code>obj</code>对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。</p>
<pre><code>const obj2 = {
  name: &#39;Jine&#39;,
  get age() { return&#39;18&#39; }
};
Object.getOwnPropertyDescriptors(obj2)
// {//   age: {//     configurable: true,//     enumerable: true,//     get: function age(){}, //the getter function//     set: undefined//   },//   name: {//     configurable: true,//     enumerable: true,//		value:&quot;Jine&quot;,//		writable:true//   }// }复制代码
</code></pre>
<h3 id="7-SharedArrayBuffer对象"><a href="#7-SharedArrayBuffer对象" class="headerlink" title="7.SharedArrayBuffer对象"></a>7.SharedArrayBuffer对象</h3><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer<br>对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。</p>
<pre><code>/**
  *
  - @param {*} length 所创建的数组缓冲区的大小，以字节(byte)为单位。
  - @returns {SharedArrayBuffer} 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。
  */new SharedArrayBuffer(length)
复制代码
</code></pre>
<h3 id="8-Atomics对象"><a href="#8-Atomics对象" class="headerlink" title="8.Atomics对象"></a>8.Atomics对象</h3><p>Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作。</p>
<p>这些原子操作属于 Atomics 模块。与一般的全局对象不同，Atomics 不是构造函数，因此不能使用 new<br>操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math 对象一样）。</p>
<p>多个共享内存的线程能够同时读写同一位置上的数据。原子操作会确保正在读或写的数据的值是符合预期的，即下一个原子操作一定会在上一个原子操作结束后才会开始，其操作过程不会中断。</p>
<ul>
<li>Atomics.add()</li>
</ul>
<blockquote>
<p>将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值。</p>
</blockquote>
<ul>
<li>Atomics.and()</li>
</ul>
<blockquote>
<p>将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。</p>
</blockquote>
<ul>
<li>Atomics.compareExchange()</li>
</ul>
<blockquote>
<p>如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。</p>
</blockquote>
<ul>
<li>Atomics.exchange()</li>
</ul>
<blockquote>
<p>将数组中指定的元素更新为给定的值，并返回该元素更新前的值。</p>
</blockquote>
<ul>
<li>Atomics.load()</li>
</ul>
<blockquote>
<p>返回数组中指定元素的值。</p>
</blockquote>
<ul>
<li>Atomics.or()</li>
</ul>
<blockquote>
<p>将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。</p>
</blockquote>
<ul>
<li>Atomics.store()</li>
</ul>
<blockquote>
<p>将数组中指定的元素设置为给定的值，并返回该值。</p>
</blockquote>
<ul>
<li>Atomics.sub()</li>
</ul>
<blockquote>
<p>将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。</p>
</blockquote>
<ul>
<li>Atomics.xor()</li>
</ul>
<blockquote>
<p>将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。</p>
</blockquote>
<p>wait() 和 wake() 方法采用的是 Linux 上的 futexes 模型（fast user-space<br>mutex，快速用户空间互斥量），可以让进程一直等待直到某个特定的条件为真，主要用于实现阻塞。</p>
<ul>
<li>Atomics.wait()</li>
</ul>
<blockquote>
<p>检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 “ok”、”not-equal” 或</p>
</blockquote>
<p>“time-out”。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。</p>
<ul>
<li>Atomics.wake()</li>
</ul>
<blockquote>
<p>唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。</p>
</blockquote>
<ul>
<li>Atomics.isLockFree(size)</li>
</ul>
<blockquote>
<p>可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics</p>
</blockquote>
<p>对象中的各原子操作都只能用锁来实现。此函数面向的是技术专家。–&gt;</p>
<h2 id="ES9新特性（2018）"><a href="#ES9新特性（2018）" class="headerlink" title="ES9新特性（2018）"></a>ES9新特性（2018）</h2><ul>
<li><p>异步迭代</p>
</li>
<li><p>Promise.finally()</p>
</li>
<li><p>Rest&#x2F;Spread 属性</p>
</li>
<li></li>
</ul>
<p><a target="_blank" rel="noopener" href="http://esnext.justjavac.com/proposal/regexp-named-groups.html">正则表达式命名捕获组</a>（Regular<br>Expression Named Capture Groups）</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006824133">正则表达式反向断言</a>（lookbehind）</li>
<li>正则表达式dotAll模式</li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b2a186cf265da596d04a648#heading-1">正则表达式 Unicode 转义</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b2a186cf265da596d04a648#heading-1">非转义序列的模板字符串</a></li>
</ul>
<h3 id="1-异步迭代"><a href="#1-异步迭代" class="headerlink" title="1.异步迭代"></a>1.异步迭代</h3><p>在<code>async/await</code>的某些时刻，你可能尝试在同步循环中调用异步函数。例如：</p>
<pre><code>asyncfunctionprocess(array) {
  for (let i of array) {
    await doSomething(i);
  }
}
复制代码
</code></pre>
<p>这段代码不会正常运行，下面这段同样也不会：</p>
<pre><code>asyncfunctionprocess(array) {
  array.forEach(async i =&gt; {
    await doSomething(i);
  });
}
复制代码
</code></pre>
<p>这段代码中，循环本身依旧保持同步，并在在内部异步函数之前全部调用完成。</p>
<p>ES2018引入异步迭代器（asynchronous<br>iterators），这就像常规迭代器，除了<code>next()</code>方法返回一个Promise。因此<code>await</code>可以和<code>for...of</code>循环一起使用，以串行的方式运行异步操作。例如：</p>
<pre><code>asyncfunctionprocess(array) {
  forawait (let i of array) {
    doSomething(i);
  }
}
复制代码
</code></pre>
<h3 id="2-Promise-finally"><a href="#2-Promise-finally" class="headerlink" title="2.Promise.finally()"></a>2.Promise.finally()</h3><p>一个Promise调用链要么成功到达最后一个<code>.then()</code>，要么失败触发<code>.catch()</code>。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除，删除对话，关闭数据库连接等。</p>
<p><code>.finally()</code>允许你指定最终的逻辑：</p>
<pre><code>functiondoSomething() {
  doSomething1()
  .then(doSomething2)
  .then(doSomething3)
  .catch(err =&gt; {
    console.log(err);
  })
  .finally(() =&gt; {
    // finish here!
  });
}
复制代码
</code></pre>
<h3 id="3-Rest-Spread-属性"><a href="#3-Rest-Spread-属性" class="headerlink" title="3.Rest&#x2F;Spread 属性"></a>3.Rest&#x2F;Spread 属性</h3><p>ES2015引入了<a href="https://link.juejin.im/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters">Rest参数</a>和<a href="https://link.juejin.im/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">扩展运算符</a>。三个点（…）仅用于数组。Rest参数语法允许我们将一个不定数量的参数表示为一个数组。</p>
<pre><code>restParam(1, 2, 3, 4, 5);

functionrestParam(p1, p2, ...p3) {
  // p1 = 1// p2 = 2// p3 = [3, 4, 5]
}
复制代码
</code></pre>
<p>展开操作符以相反的方式工作，将数组转换成可传递给函数的单独参数。例如<code>Math.max()</code>返回给定数字中的最大值：</p>
<pre><code>const values = [99, 100, -1, 48, 16];
console.log( Math.max(...values) ); // 100
复制代码
</code></pre>
<p>ES2018为对象解构提供了和数组一样的Rest参数（）和展开操作符，一个简单的例子：</p>
<pre><code>const myObject = {
  a: 1,
  b: 2,
  c: 3
};

const { a, ...x } = myObject;
// a = 1// x = { b: 2, c: 3 }复制代码
</code></pre>
<p>或者你可以使用它给函数传递参数：</p>
<pre><code>restParam({
  a: 1,
  b: 2,
  c: 3
});

functionrestParam({ a, ...x }) {
  // a = 1// x = { b: 2, c: 3 }
}
复制代码
</code></pre>
<p>跟数组一样，Rest参数只能在声明的结尾处使用。此外，它只适用于每个对象的顶层，如果对象中嵌套对象则无法适用。</p>
<p>扩展运算符可以在其他对象内使用，例如：</p>
<pre><code>const obj1 = { a: 1, b: 2, c: 3 };
const obj2 = { ...obj1, z: 26 };
// obj2 is { a: 1, b: 2, c: 3, z: 26 }复制代码
</code></pre>
<p>可以使用扩展运算符拷贝一个对象，像是这样<code>obj2 = {...obj1}</code>，但是<br><strong>这只是一个对象的浅拷贝</strong>。另外，如果一个对象A的属性是对象B，那么在克隆后的对象cloneB中，该属性指向对象B。</p>
<h3 id="4-正则表达式命名捕获组"><a href="#4-正则表达式命名捕获组" class="headerlink" title="4.正则表达式命名捕获组"></a>4.正则表达式命名捕获组</h3><p>JavaScript正则表达式可以返回一个匹配的对象——一个包含匹配字符串的类数组，例如：以<code>YYYY-MM-DD</code>的格式解析日期：</p>
<pre><code>const
  reDate = /([0-9]{4})-([0-9]{2})-([0-9]{2})/,
  match  = reDate.exec(&#39;2018-04-30&#39;),
  year   = match[1], // 2018
  month  = match[2], // 04
  day    = match[3]; // 30复制代码
</code></pre>
<p>这样的代码很难读懂，并且改变正则表达式的结构有可能改变匹配对象的索引。</p>
<p>ES2018允许命名捕获组使用符号<code>?&lt;name&gt;</code>，在打开捕获括号<code>(</code>后立即命名，示例如下：</p>
<pre><code>const
  reDate = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/,
  match  = reDate.exec(&#39;2018-04-30&#39;),
  year   = match.groups.year,  // 2018
  month  = match.groups.month, // 04
  day    = match.groups.day;   // 30复制代码
</code></pre>
<p>任何匹配失败的命名组都将返回<code>undefined</code>。</p>
<p>命名捕获也可以使用在<code>replace()</code>方法中。例如将日期转换为美国的 MM-DD-YYYY 格式：</p>
<pre><code>const
  reDate = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/,
  d      = &#39;2018-04-30&#39;,
  usDate = d.replace(reDate, &#39;$&lt;month&gt;-$&lt;day&gt;-$&lt;year&gt;&#39;);
复制代码
</code></pre>
<h3 id="5-正则表达式反向断言"><a href="#5-正则表达式反向断言" class="headerlink" title="5.正则表达式反向断言"></a>5.正则表达式反向断言</h3><p>目前JavaScript在正则表达式中支持先行断言（lookahead）。这意味着匹配会发生，但不会有任何捕获，并且断言没有包含在整个匹配字段中。例如从价格中捕获货币符号：</p>
<pre><code>const
  reLookahead = /\D(?=\d+)/,
  match       = reLookahead.exec(&#39;$123.89&#39;);

console.log( match[0] ); // $复制代码
</code></pre>
<p>ES2018引入以相同方式工作但是匹配前面的反向断言（lookbehind），这样我就可以忽略货币符号，单纯的捕获价格的数字：</p>
<pre><code>const
  reLookbehind = /(?&lt;=\D)\d+/,
  match        = reLookbehind.exec(&#39;$123.89&#39;);

console.log( match[0] ); // 123.89复制代码
</code></pre>
<p>以上是 <strong>肯定反向断言</strong>，非数字<code>\D</code>必须存在。同样的，还存在 <strong>否定反向断言</strong>，表示一个值必须不存在，例如：</p>
<pre><code>const
  reLookbehindNeg = /(?&lt;!\D)\d+/,
  match           = reLookbehind.exec(&#39;$123.89&#39;);

console.log( match[0] ); // null复制代码
</code></pre>
<h3 id="6-正则表达式dotAll模式"><a href="#6-正则表达式dotAll模式" class="headerlink" title="6.正则表达式dotAll模式"></a>6.正则表达式dotAll模式</h3><p>正则表达式中点<code>.</code>匹配除回车外的任何单字符，标记<code>s</code>改变这种行为，允许行终止符的出现，例如：</p>
<pre><code>/hello.world/.test(&#39;hello\nworld&#39;);  // false
/hello.world/s.test(&#39;hello\nworld&#39;); // true复制代码
</code></pre>
<h3 id="7-正则表达式-Unicode-转义"><a href="#7-正则表达式-Unicode-转义" class="headerlink" title="7.正则表达式 Unicode 转义"></a>7.正则表达式 Unicode 转义</h3><p>到目前为止，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES2018添加了 Unicode<br>属性转义——形式为<code>\p{...}</code>和<code>\P{...}</code>，在正则表达式中使用标记 <code>u</code> (unicode)<br>设置，在<code>\p</code>块儿内，可以以键值对的方式设置需要匹配的属性而非具体内容。例如：</p>
<pre><code>const reGreekSymbol = /\p{Script=Greek}/u;
reGreekSymbol.test(&#39;π&#39;); // true复制代码
</code></pre>
<p>此特性可以避免使用特定 Unicode 区间来进行内容类型判断，提升可读性和可维护性。</p>
<h3 id="8-非转义序列的模板字符串"><a href="#8-非转义序列的模板字符串" class="headerlink" title="8.非转义序列的模板字符串"></a>8.非转义序列的模板字符串</h3><p>之前，<code>\u</code>开始一个 unicode<br>转义，<code>\x</code>开始一个十六进制转义，<code>\</code>后跟一个数字开始一个八进制转义。这使得创建特定的字符串变得不可能，例如Windows文件路径<br><code>C:\uuu\xxx\111</code>。更多细节参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings">模板字符串</a>。</p>
<h2 id="ES10新特性（2019）"><a href="#ES10新特性（2019）" class="headerlink" title="ES10新特性（2019）"></a>ES10新特性（2019）</h2><ul>
<li>行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与JSON匹配</li>
<li>更加友好的 JSON.stringify</li>
<li>新增了Array的<code>flat()</code>方法和<code>flatMap()</code>方法</li>
<li>新增了String的<code>trimStart()</code>方法和<code>trimEnd()</code>方法</li>
<li><code>Object.fromEntries()</code></li>
<li><code>Symbol.prototype.description</code></li>
<li><code>String.prototype.matchAll</code></li>
<li><code>Function.prototype.toString()</code>现在返回精确字符，包括空格和注释</li>
<li>简化<code>try {} catch {}</code>,修改 <code>catch</code> 绑定</li>
<li>新的基本数据类型<code>BigInt</code></li>
<li>globalThis</li>
<li>import()</li>
<li>Legacy RegEx</li>
<li>私有的实例方法和访问器</li>
</ul>
<h3 id="1-行分隔符（U-2028）和段分隔符（U-2029）符号现在允许在字符串文字中，与JSON匹配"><a href="#1-行分隔符（U-2028）和段分隔符（U-2029）符号现在允许在字符串文字中，与JSON匹配" class="headerlink" title="1.行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与JSON匹配"></a>1.行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与JSON匹配</h3><p>以前，这些符号在字符串文字中被视为行终止符，因此使用它们会导致SyntaxError异常。</p>
<h3 id="2-更加友好的-JSON-stringify"><a href="#2-更加友好的-JSON-stringify" class="headerlink" title="2.更加友好的 JSON.stringify"></a>2.更加友好的 JSON.stringify</h3><p>如果输入 Unicode<br>格式但是超出范围的字符，在原先JSON.stringify返回格式错误的Unicode字符串。现在实现了一个改变JSON.stringify的<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-well-formed-stringify">第3阶段提案</a>，因此它为其输出转义序列，使其成为有效Unicode（并以UTF-8表示）</p>
<h3 id="3-新增了Array的flat-方法和flatMap-方法"><a href="#3-新增了Array的flat-方法和flatMap-方法" class="headerlink" title="3.新增了Array的flat()方法和flatMap()方法"></a>3.新增了Array的<code>flat()</code>方法和<code>flatMap()</code>方法</h3><p><code>flat()</code>和<code>flatMap()</code>本质上就是是归纳（reduce） 与 合并（concat）的操作。</p>
<h4 id="Array-prototype-flat"><a href="#Array-prototype-flat" class="headerlink" title="Array.prototype.flat()"></a>Array.prototype.flat()</h4><p><code>flat()</code> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p>
<ul>
<li><p><code>flat()</code>方法最基本的作用就是数组降维</p>
<p>  var arr1 &#x3D; [1, 2, [3, 4]];<br>  arr1.flat();<br>  &#x2F;&#x2F; [1, 2, 3, 4]var arr2 &#x3D; [1, 2, [3, 4, [5, 6]]];<br>  arr2.flat();<br>  &#x2F;&#x2F; [1, 2, 3, 4, [5, 6]]var arr3 &#x3D; [1, 2, [3, 4, [5, 6]]];<br>  arr3.flat(2);<br>  &#x2F;&#x2F; [1, 2, 3, 4, 5, 6]&#x2F;&#x2F;使用 Infinity 作为深度，展开任意深度的嵌套数组<br>  arr3.flat(Infinity);<br>  &#x2F;&#x2F; [1, 2, 3, 4, 5, 6]复制代码</p>
</li>
<li><p>其次，还可以利用<code>flat()</code>方法的特性来去除数组的空项</p>
<p>  var arr4 &#x3D; [1, 2, , 4, 5];<br>  arr4.flat();<br>  &#x2F;&#x2F; [1, 2, 4, 5]复制代码</p>
</li>
</ul>
<h4 id="Array-prototype-flatMap"><a href="#Array-prototype-flatMap" class="headerlink" title="Array.prototype.flatMap()"></a>Array.prototype.flatMap()</h4><p><code>flatMap()</code> 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap<br>通常在合并成一种方法的效率稍微高一些。<br>这里我们拿map方法与flatMap方法做一个比较。</p>
<pre><code>var arr1 = [1, 2, 3, 4];

arr1.map(x =&gt; [x * 2]);
// [[2], [4], [6], [8]]

arr1.flatMap(x =&gt; [x * 2]);
// [2, 4, 6, 8]// 只会将 flatMap 中的函数返回的数组 “压平” 一层
arr1.flatMap(x =&gt; [[x * 2]]);
// [[2], [4], [6], [8]]复制代码
</code></pre>
<h3 id="4-新增了String的trimStart-方法和trimEnd-方法"><a href="#4-新增了String的trimStart-方法和trimEnd-方法" class="headerlink" title="4.新增了String的trimStart()方法和trimEnd()方法"></a>4.新增了String的<code>trimStart()</code>方法和<code>trimEnd()</code>方法</h3><p>新增的这两个方法很好理解，分别去除字符串首尾空白字符，这里就不用例子说声明了。</p>
<h3 id="5-Object-fromEntries"><a href="#5-Object-fromEntries" class="headerlink" title="5.Object.fromEntries()"></a>5.<code>Object.fromEntries()</code></h3><p><code>Object.entries()</code>方法的作用是返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in<br>循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。</p>
<p><strong>而<code>Object.fromEntries()</code> 则是 <code>Object.entries()</code> 的反转。</strong></p>
<p><code>Object.fromEntries()</code><br>函数传入一个键值对的列表，并返回一个带有这些键值对的新对象。这个迭代参数应该是一个能够实现@iterator方法的的对象，返回一个迭代器对象。它生成一个具有两个元素的类似数组的对象，第一个元素是将用作属性键的值，第二个元素是与该属性键关联的值。</p>
<ul>
<li><p>通过 Object.fromEntries， 可以将 Map 转化为 Object:</p>
<p>  const map &#x3D; newMap([ [‘foo’, ‘bar’], [‘baz’, 42] ]);<br>  const obj &#x3D; Object.fromEntries(map);<br>  console.log(obj); &#x2F;&#x2F; { foo: “bar”, baz: 42 }复制代码</p>
</li>
<li><p>通过 Object.fromEntries， 可以将 Array 转化为 Object:</p>
<p>  const arr &#x3D; [ [‘0’, ‘a’], [‘1’, ‘b’], [‘2’, ‘c’] ];<br>  const obj &#x3D; Object.fromEntries(arr);<br>  console.log(obj); &#x2F;&#x2F; { 0: “a”, 1: “b”, 2: “c” }复制代码</p>
</li>
</ul>
<h3 id="6-Symbol-prototype-description"><a href="#6-Symbol-prototype-description" class="headerlink" title="6.Symbol.prototype.description"></a>6.<code>Symbol.prototype.description</code></h3><p>通过工厂函数Symbol（）创建符号时，您可以选择通过参数提供字符串作为描述：</p>
<pre><code>const sym = Symbol(&#39;The description&#39;);
复制代码
</code></pre>
<p>以前，访问描述的唯一方法是将符号转换为字符串：</p>
<pre><code>assert.equal(String(sym), &#39;Symbol(The description)&#39;);
复制代码
</code></pre>
<p>现在引入了getter Symbol.prototype.description以直接访问描述：</p>
<pre><code>assert.equal(sym.description, &#39;The description&#39;);
复制代码
</code></pre>
<h3 id="7-String-prototype-matchAll"><a href="#7-String-prototype-matchAll" class="headerlink" title="7.String.prototype.matchAll"></a>7.<code>String.prototype.matchAll</code></h3><p><code>matchAll()</code> 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器。<br>在 matchAll 出现之前，通过在循环中调用regexp.exec来获取所有匹配项信息（regexp需使用&#x2F;g标志：</p>
<pre><code>const regexp = RegExp(&#39;foo*&#39;,&#39;g&#39;);
const str = &#39;table football, foosball&#39;;

while ((matches = regexp.exec(str)) !== null) {
  console.log(`Found ${matches[0]}. Next starts at ${regexp.lastIndex}.`);
  // expected output: &quot;Found foo. Next starts at 9.&quot;// expected output: &quot;Found foo. Next starts at 19.&quot;
}
复制代码
</code></pre>
<p>如果使用matchAll ，就可以不必使用while循环加exec方式（且正则表达式需使用／g标志）。使用matchAll 会得到一个迭代器的返回值，配合<br>for…of, array spread, or Array.from() 可以更方便实现功能：</p>
<pre><code>const regexp = RegExp(&#39;foo*&#39;,&#39;g&#39;);
const str = &#39;table football, foosball&#39;;
let matches = str.matchAll(regexp);

for (const match of matches) {
  console.log(match);
}
// Array [ &quot;foo&quot; ]// Array [ &quot;foo&quot; ]// matches iterator is exhausted after the for..of iteration// Call matchAll again to create a new iterator
matches = str.matchAll(regexp);

Array.from(matches, m =&gt; m[0]);
// Array [ &quot;foo&quot;, &quot;foo&quot; ]复制代码
</code></pre>
<h4 id="matchAll可以更好的用于分组"><a href="#matchAll可以更好的用于分组" class="headerlink" title="matchAll可以更好的用于分组"></a>matchAll可以更好的用于分组</h4><pre><code>var regexp = /t(e)(st(\d?))/g;
var str = &#39;test1test2&#39;;

str.match(regexp);
// Array [&#39;test1&#39;, &#39;test2&#39;]复制代码

let array = [...str.matchAll(regexp)];

array[0];
// [&#39;test1&#39;, &#39;e&#39;, &#39;st1&#39;, &#39;1&#39;, index: 0, input: &#39;test1test2&#39;, length: 4]
array[1];
// [&#39;test2&#39;, &#39;e&#39;, &#39;st2&#39;, &#39;2&#39;, index: 5, input: &#39;test1test2&#39;, length: 4]复制代码
</code></pre>
<h3 id="8-Function-prototype-toString-现在返回精确字符，包括空格和注释"><a href="#8-Function-prototype-toString-现在返回精确字符，包括空格和注释" class="headerlink" title="8.Function.prototype.toString()现在返回精确字符，包括空格和注释"></a>8.<code>Function.prototype.toString()</code>现在返回精确字符，包括空格和注释</h3><pre><code>function /* comment */ foo /* anothercomment */() {}

// 之前不会打印注释部分console.log(foo.toString()); // function foo(){}// ES2019 会把注释一同打印console.log(foo.toString()); // function /* comment */ foo /* another comment */ (){}// 箭头函数const bar /* comment */ = /* another comment */ () =&gt; {};

console.log(bar.toString()); // () =&gt; {}复制代码
</code></pre>
<h3 id="9-修改-catch-绑定"><a href="#9-修改-catch-绑定" class="headerlink" title="9.修改 catch 绑定"></a>9.修改 <code>catch</code> 绑定</h3><p>在 ES10 之前，我们必须通过语法为 catch 子句绑定异常变量，无论是否有必要。很多时候 catch 块是多余的。 ES10<br>提案使我们能够简单的把变量省略掉。</p>
<p>不算大的改动。</p>
<p>之前是</p>
<pre><code>try {} catch(e) {}
复制代码
</code></pre>
<p>现在是</p>
<pre><code>try {} catch {}
复制代码
</code></pre>
<h3 id="10-新的基本数据类型BigInt"><a href="#10-新的基本数据类型BigInt" class="headerlink" title="10.新的基本数据类型BigInt"></a>10.新的基本数据类型<code>BigInt</code></h3><p>现在的基本数据类型（值类型）不止5种（ES6之后是六种）了哦！加上BigInt一共有七种基本数据类型，分别是：<br>String、Number、Boolean、Null、Undefined、Symbol、BigInt</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b9cb3336fb9a05d290ee47e">ES6、ES7、ES8学习指南</a></p>
</div><iframe src="/donate/?AliPayQR=/img/AliPayQR.png&amp;WeChatQR=/img/WeChatQR.png&amp;UnionPayQR=null&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=https://paypal.me/BigOldTwo&amp;afd=https://ifdian.net/order/create?user_id=1f326f88329e11eeb16752540025c377" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>搬砖大老</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/article/dc8dc705.html">https://xuehuayu.cn/article/dc8dc705.html</a></li><li class="post-copyright-license"><strong>版权声明：</strong>① 标为原创的文章为博主原创，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接。② 部分文章内容由 AI 生成，内容仅供参考，请仔细甄别。③ 标为转载的文章来自网络，已标明出处，<a href="mailto:boss@xuehuayu.cn">侵删</a>。</li></ul></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/article/a974109a.html">48个 JS 开发常用工具函数</a><a class="next" href="/article/e1de1ab.html">前端面试题汇总大全（含答案）-- 持续更新</a></div><div id="waline-comment"></div><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@waline/client@v2/dist/waline.min.css"><script src="//cdn.jsdelivr.net/npm/@waline/client@v2/dist/waline.min.js"></script><script>const origin = window.location.origin
const serverURL = origin.includes('cainiaoblog') ? 'https://guest.cainiaoblog.cn' : 'https://guest.xuehuayu.cn'
const locale = {
  placeholder: '请正确填写昵称和邮箱，方便接收回复通知~',
  sofa: '沙发空缺中，还不快抢~',
  admin: '管理员'
};
Waline.init({
  el: '#waline-comment',
  serverURL: serverURL,
  locale,
  pageSize: '20',
  visitor: false == true, // 阅读量统计
  requiredMeta: ['nick', 'mail'],
  pageview: true,
  reaction: true,
  emoji: [
    '//cdn.jsdelivr.net/npm/@waline/emojis@1.2.0/qq',
    '//cdn.jsdelivr.net/npm/@waline/emojis@1.2.0/bmoji',
    '//cdn.jsdelivr.net/npm/@waline/emojis@1.2.0/weibo',
    '//cdn.jsdelivr.net/npm/@waline/emojis@1.2.0/tieba',
    '//cdn.jsdelivr.net/npm/@waline/emojis@1.2.0/tw-emoji',
    '//cdn.jsdelivr.net/npm/@waline/emojis@1.2.0/alus',
    '//cdn.jsdelivr.net/npm/@waline/emojis@1.2.0/bilibili',
    '//cdn.jsdelivr.net/npm/@waline/emojis@1.2.0/soul-emoji'
  ],
})</script></div></div></div><div class="pure-u-1 pure-u-md-1-4 fixed-search hidden_mid_and_down"><div id="sidebar"><script type="text/javascript" src="/js/search.js"></script><div class="widget widget-all-search"><div class="widget-search"><input class="search" type="radio" name="search" value="baidu" id="baidu" checked="checked"/><label class="label" for="baidu" title="百度全站搜索">百度</label><input class="search" type="radio" name="search" value="google" id="google"/><label class="label" for="google" title="谷歌全站搜索">谷歌</label><input class="search" type="radio" name="search" value="self" id="self"/><label class="label" for="self" title="使用站内搜索">站内</label></div><div class="widget" id="search"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="30" placeholder="百度全站搜索"/><input type="hidden" name="si" value="xuehuayu.cn"/><input type="hidden" name="cl" value="3"/><input type="hidden" name="ct" value="2097152"/><input type="hidden" name="s" value="on"/><input class="search-submit" type="submit" value=""/></form></div></div><script>$('input[type=radio][name=search]').change(function() {
  var val = $(this).val()
  var self = '<div class="search-form"><input id="local-search-input" placeholder="站内搜索，首次慢" type="search" name="q" results="0"><input class="search-submit" type="submit" value=""/><div id="local-search-result"></div></div>'
  var google = '<form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="q" maxlength="30" placeholder="谷歌全站搜索"><input type="hidden" name="sitesearch" value="xuehuayu.cn"><input class="search-submit" type="submit" value=""/></form>'
  var baidu = '<form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="30" placeholder="百度全站搜索"><input type="hidden" name="si" value="xuehuayu.cn"><input type="hidden" name="cl" value="3"><input type="hidden" name="ct" value="2097152"><input type="hidden" name="s" value="on"><input class="search-submit" type="submit" value=""/></form>'

  if (val === 'self') {
      $('#search').html(self)
      var search_path = 'search.xml';
      if (search_path.length == 0) {
        search_path = '//search.xml';
      }
      var path = '/' + search_path;
      searchFunc(path, 'local-search-input', 'local-search-result');
  } else if (val === 'baidu') {
      $('#search').html(baidu)
  } else if (val === 'google') {
      $('#search').html(google)
  }
})</script><div class="widget widget-wxmp"><img alt="微信公众号" width="100%" src="/img/mp-mini.png"/></div><div class="widget widget-recent-posts"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/article/ead1a366.html">vue3 pinia在App.vue中使用了useStore报错getActivePinia() was called but there wa no active pinia</a></li><li class="post-list-item"><a class="post-list-link" href="/article/abe47f31.html">vue3中的mixin写法使用Composition API 来实现代码复用</a></li><li class="post-list-item"><a class="post-list-link" href="/article/cbf3079f.html">windows虚拟内存自动管理好还是手动设置好？ 如果是手动设置多少合适？</a></li><li class="post-list-item"><a class="post-list-link" href="/article/763d6087.html">vue3中ts提示扩张参数必须具有元组类型或传递给rest参数</a></li><li class="post-list-item"><a class="post-list-link" href="/article/2f775138.html">vue3 组件 has no default export</a></li></ul></div><div class="widget widget-recent-comments"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><div class="waline-recent" id="waline-recent"></div></div><script type="module">//- import { RecentComments } from  '//cdn.jsdelivr.net/npm/@waline/client/dist/waline.mjs';
import { RecentComments } from  'https://xuehuayu.cn/js/waline.mjs';

const origin = window.location.origin
const serverURL = origin.includes('cainiaoblog') ? 'https://guest.cainiaoblog.cn' : 'https://guest.xuehuayu.cn'

RecentComments({
  el: '#waline-recent',
  serverURL,
  count: 5,
}).then(({ comments }) => {
  const commentList = comments.map(
    (comment) => {
      const cmts = ((comment||{}).comment || '').replace(/<\/?.*?>/g, '').replace(/\n/g, ' ')
      const time = ((comment||{}).insertedAt || '').substring(0, 10)
      const link = (comment||{}).link
      const info = link ? `<a class="flex-block align-center" href="${link}"><img class="comment-avatar" width="30" src="${comment.avatar}" alt="${comment.nick}"/><span class="comment-nick">${comment.nick}</span></a>` : `<img class="comment-avatar" width="30" src="${comment.avatar}" alt="${comment.nick}"/><span class="comment-nick">${comment.nick}</span>`
      const url = (comment||{}).url + '#' + (comment||{}).objectId
      return `<li class="comment-list-item"><div class="comment-top flex-block justify-between align-center"><div class="comment-info flex-block align-center">${info}</div><span>${time}</span></div><div class="comment-content"><a class="post-list-link line-3" href="${url}">${cmts}</a></div></li>`
    }
  );
  document.getElementById('waline-recent').innerHTML = `<url class="comment-list">${commentList.join('')}</ul>`
});</script><div class="widget widget-categories"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ADBlock/">ADBlock</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/">Blog</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/FrontEnd/">FrontEnd</a><span class="category-list-count">277</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Histiry/">Histiry</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/KKPlayer/">KKPlayer</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Movies/">Movies</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E7%A8%8E/">个税</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%84%BF%E7%AB%A5/">儿童</a><span class="category-list-count">8</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%84%BF%E7%AB%A5/%E5%81%A5%E5%BA%B7/">健康</a><span class="category-list-count">8</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%84%BF%E7%AB%A5/%E5%81%A5%E5%BA%B7/children/">children</a><span class="category-list-count">8</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%84%BF%E7%AB%A5/%E5%81%A5%E5%BA%B7/children/health/">health</a><span class="category-list-count">8</span></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7/">公众号</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">292</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/FrontEnd/">FrontEnd</a><span class="category-list-count">16</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8E%86%E5%8F%B2/">历史</a><span class="category-list-count">6</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8E%86%E5%8F%B2/Histiry/">Histiry</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%BF%E5%91%8A%E8%BF%87%E6%BB%A4/">广告过滤</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BD%B1%E8%A7%86/">影视</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B8%B8%E6%88%8F/">游戏</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A5%9E%E8%AF%9D/">神话</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%B3%BB%E7%BB%9F/">系统</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%B3%BB%E7%BB%9F/System/">System</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%9B%98/">网盘</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%8A%82%E7%82%B9/">节点</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%A3%85%E4%BF%AE/">装修</a><span class="category-list-count">1</span></li></ul></div><div class="widget widget-links"><div class="widget-title"><i class="fa fa-external-link"> 友链</i></div><ul><li><a href="https://h5.lot-ml.com/ProductEn/Index/1be1066f15176ef6/?utm_source=xuehuayu.cn&amp;utm_term=KKPlayer" title="四大运营商大流量手机卡终身套餐" target="_blank">四大运营商大流量手机卡终身套餐</a></li><li><a href="https://m3u8.xuehuayu.cn?utm_source=xuehuayu.cn&amp;utm_term=KKPlayer" title="M3U8加速播放器" target="_blank">M3U8加速播放器</a></li><li><a href="https://chrome.xuehuayu.cn?utm_source=xuehuayu.cn&amp;utm_term=KKPlayer" title="Chrome命令行参数生成器" target="_blank">Chrome命令行参数生成器</a></li><li><a href="https://laonongmin.online?utm_source=xuehuayu.cn&amp;utm_term=KKPlayer" title="KK Player" target="_blank">KK Player</a></li></ul></div><div class="widget widget-ip"><div class="widget-title"></div><img alt="info" width="100%" src="https://tool.lu/netcard/" onclick="window.open(&quot;https://laonongmin.online&quot;)"/></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"><div class="flex-block justify-center align-center flex-wrap"><a class="gxba-link" id="gxba" rel="nofollow" target="_blank" href="http://beian.miit.gov.cn/">京ICP备20007647号-2</a><a class="gaba-link" id="gaba-link" rel="nofollow" target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802031264"><img class="nofancybox" src="/img/gaba.png" alt=""/><span id="gaba">京公网安备 11010802031264号</span><span style="padding-right: 10px;"></span></a><span>Copyright © 2025 </span><a href="/." rel="nofollow">前端壹菜鸟. </a><script>(function(){
  var cnb =window.location.origin.includes('cainiaoblog')
  if (cnb) {
    var gxba =document.getElementById('gxba')
    var gaba =document.getElementById('gaba')
    var gabaLink =document.getElementById('gaba-link')
    gxba.innerText ='京ICP备20007647号-1'
    gaba.innerText ='京公网安备 11010802031254号'
    gabaLink.setAttribute('href','http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802031254')
  }
})()</script></div></div></div></div><a class="show" id="rocket" title="返回顶部" href="#top"></a><div class="darkmode-toggle" title="开灯/关灯">🌓</div><script type="text/javascript" src="/js/totop.js?v=9" async></script><script type="text/javascript" src="/js/dark.js?v=9" async></script><script type="text/javascript" src="/js/codeblock-resizer.js"></script><script type="text/javascript" src="/js/smartresize.js"></script></div></body><div class="footer-links"><i class="fa fa-external-link"> 友链</i><span>：</span><span class="link"><span class="gap gap-0">|</span><a href="https://h5.lot-ml.com/ProductEn/Index/1be1066f15176ef6/?utm_source=xuehuayu.cn&amp;utm_term=KKPlayer" title="四大运营商大流量手机卡终身套餐" target="_blank">四大运营商大流量手机卡终身套餐</a></span><span class="link"><span class="gap gap-1">|</span><a href="https://m3u8.xuehuayu.cn?utm_source=xuehuayu.cn&amp;utm_term=KKPlayer" title="M3U8加速播放器" target="_blank">M3U8加速播放器</a></span><span class="link"><span class="gap gap-2">|</span><a href="https://chrome.xuehuayu.cn?utm_source=xuehuayu.cn&amp;utm_term=KKPlayer" title="Chrome命令行参数生成器" target="_blank">Chrome命令行参数生成器</a></span><span class="link"><span class="gap gap-3">|</span><a href="https://laonongmin.online?utm_source=xuehuayu.cn&amp;utm_term=KKPlayer" title="KK Player" target="_blank">KK Player</a></span></div></html>